---
path: '/part-1/2-inheritance'
title: 'Наследование'
hidden: false
---

<text-box variant='learningObjectives' name='Learning objectives'>

В этом разделе вы узнаете, как

- Задавать наследование в Logtalk между простыми объектами
- Вызывать методы, унаследованные у родителя
- Загружать небольшие объектные иерархии из файлов

</text-box>

_Наследование_ в объекно-ориентированных языках - это средство проектирования новых объектов на основе существующих, добавяля их свойства в создаваемый объект.  В Logtalk наследовать в том или ином виде свойства могут любые объекты.  Самый очевидный вариант наследования - это создание производных объектов из существующих.

Давайте создадим объект ```family_base/0```, который будет описывать основные родственные отношения.

```logtalk
% File:family_base.lgt

:- object(family_base).

   :- public([
      man/1,    % мужчина(<кто>)
      woman/1,  % женщина(<кто>)
      parent/2, % родитель(<кто>,<чей>)
      mother/2, % отец(<кто>,<чей>)
      father/2  % мать(<кто>,<чей>)
   ]).

   % Не будем здесь задавать
   % конкретных людей и кто, чей
   % родитель.
   % Зададим
   % правила распознавания для
   % отца и матери

   mother(Who, Whose) :-
      woman(Who),
      parent(Who, Whose).

   father(Who, Whose) :-
      man(Who),
      parent(Who, Whose).

:- end_object.
```

Выполнив запрос, как показано ниже, мы не получим положительного (```true``` или ```yes```) ответа.

<sample-output>

?- **{family_base}.**
<p class="green">% [ /home/eugeneai/tmp/tst/family_base.lgt loaded ]
% (0 warnings)</p>
true.

?- **family_base::mother(Who, Whose).**
<b class='errLog'>false</b>.

</sample-output>

Ответ отрицательный, точнее _не положительный_: Logtalk не может вывести (установить) истинен ли запрос. В данном случае это невозможно, так как нет данных о конкретном составе семьи.  Соства мы можем сформировать в данном примере через наследование.  Состав мы можем инкапсулировать в отдельном объекте, помещенный в отдельный файл.

```logtalk
% File: family_pat.lgt

:- object(family_pat,
      extends(family_base)).

   man(max).

   woman(pat).
   woman(jill).

   parent(max, jill).
   parent(pat, jill).

:- end_object.
```

В коде выше, директива ```extends``` реализует вариант наследования, при котором объект ```family_pat/0``` строиться на основе ```family_base/0```, при этом методы ```mother/2``` и ```father/2``` "копируются" в ```family_pat/0```.  Теперь, последовательно загрузив два файла ```family_base.lgt``` и ```family_pat.lgt``` получаем два объекта.  Но запрос опять на приводит к желанному результату.

<sample-output>

?- **{family_base}**.
<b class="green">% [ /home/eugeneai/tmp/tst/family_base.lgt already loaded; skipping ]
% (0 warnings)</b>
true.

?- **{family_pat}**.
<b class="green">% [ /home/eugeneai/tmp/tst/family_pat.lgt loaded ]
% (0 warnings)</b>
true.

?- **family_pat::mother(Who, Whose).**
<b class='errLog'>false.</b>

</sample-output>

Неочевидная проблема тут следующая: при задании правил использованы вызовы _локальных предикатов_. В Logtalk, как и в других языках ООП, сообщениями называются вызовы методов. Сообщения посылаются одним объектом к другому.  Сообщения посылаются или в виде ```<приемник>::<метод>[(<параметры>)]``` или ```::<метод>[(<параметры>)]```.  Квадратные скобки здесь обозначают тот факт, что параметры и круглые скобки могут отсутствовать, если мообщение не имеет параметров.  Второй вариант - это посылка сообщения к самому себе.  Мы задали правила ```mother/2``` и ```father/2``` в стиле Prolog, не задейстовав лператор ```::```.

```text
   % . . . . . . . . .

   mother(Who, Whose) :-
      woman(Who),
      parent(Who, Whose).

   father(Who, Whose) :-
      man(Who),
      parent(Who, Whose).

   % . . . . . . . . .
```

В таком случае Logtalk считает, что ```man/1```, ```woman/1``` и ```parent/2``` - это какие-то вспомогательные предикаты, использованные для реализации методов ```mother/2``` и ```father/2``` - внутреннее дело объекта ```family_base```.  Чтобы наши методы "увидели" факты из ```family_pat/2```, надо в объект ```family_base``` добавить посылку сообщений ```::man(...)```, ```::woman(...)``` и ```parent(..., ...)``` к *самому себе*.

```logtalk
% File:family_base.lgt

:- object(family_base).

   :- public([
      man/1,    % мужчина(<кто>)
      woman/1,  % женщина(<кто>)
      parent/2, % родитель(<кто>,<чей>)
      mother/2, % отец(<кто>,<чей>)
      father/2  % мать(<кто>,<чей>)
   ]).

   % Не будем здесь задавать
   % конкретных людей и кто, чей
   % родитель.
   % Зададим
   % правила распознавания для
   % отца и матери

   mother(Who, Whose) :-
      ::woman(Who),
      ::parent(Who, Whose).

   father(Who, Whose) :-
      ::man(Who),
      ::parent(Who, Whose).

:- end_object.
```

Теперь наш запрос выполняется успешно.

<sample-output>

?- **{family_base}.**
<b class="green">% [ /home/eugeneai/tmp/tst/family_base.lgt loaded ]
% (0 warnings)</b>
true.

?- **{family_pat}.**
<b class="green">% [ /home/eugeneai/tmp/tst/family_pat.lgt loaded ]
% (0 warnings)</b>
true.

?- **family_pat::mother(Who, Whose).**
Who = pat,
Whose = jill **;**
<b class='errLog'>false</b>.

</sample-output>

Сперва выдается ответ ```Who = pat, Whose = jill```, что соответствует успешному результату, потом пользователь нажимает "```;```", пытаясь получить еще один положительный ответ, но не получает его, так как больше таких ответов нет.

Терер, если первый вариант объекта ```family_base/0```, где ```mother/2``` реализован без посылки сообщений к самому себе, загрузить в режиме компиляции Logtalk, мы получим список ошибок.

<sample-output>

$ **swilgt family.lgt**
Logtalk 3.86.0
Copyright (c) 1998-2024 Paulo Moura
<b class="green">% Очень много всяких строк настроек. </b>
% . . . . . . .
<b class='errLog'>\*     Declared static predicate called but not defined: woman/1
\*       while compiling object family_base
\*       in file /home/eugeneai/tmp/tst/family_base.lgt between lines 17-19
\*
\*     Declared static predicate called but not defined: parent/2
\*       while compiling object family_base
\*       in file /home/eugeneai/tmp/tst/family_base.lgt between lines 17-19
\*
% . . . . . . . </b>

</sample-output>

Ошибки показывают, например, что правило ```mother/2``` реализуется на освнове предикатов ```woman/2``` и ```parent/2```, используемыми локально и утилитарно.  Однако эти вспомогательные предикаты не определены!  Отсутствие ```woman/2``` и ```parent/2``` в локальном контексте приводит к одному из двух исходов в зависимости от натроек интерпретатора Prolog: 1) создается исключение, что эти предикаты не определены (это как раз наш рассматриваемый сейчас случай), либо 2) эти предикаты не могут быть выведены, то есть ложные (это случай первого примера в этом разделе).

Таким образом, для того, чтобы **унаследованные** предикаты видели **новые** и наоборот, необходимо в реализации тел методов использовать сообщения ```::<метод>[(<параметры>)]``` к самому себе.

## Вызовы унаследованных методов

Все было хорошо в семье ```family_pat/0```, да родился еще один ребенок ```john```!  И стало в семье еще лучше!... Как нам представить новое положение дел в семье Патриции?

Первый вариант - добавить Джона в объект ```family_pat/0```.  Способ простой, но только, если от существующего ранее положения дел зависили какие-то другие объекты (через посылку сообщей).  Новые ответы, неожиданные ответы, включающие Джона, в общем случае могут удивить старый код.

Второй ваиант, уважающий природную "статическую" парадигму Logtalk - это создать новый объект ```family_pat_2/0```, наследующий все, что было в ```family_pat/0``` и добавляющий нового члена семьи.

```logtalk
% File: family_pat_2.lgt

:- object(family_pat_2,
      extends(family_pat)).

   man(john).
   parent(pat, john).
   parent(max, john).

:- end_object.
```

Посмотрим, что получилось. В выводе программы оставлена только необходимая раскарасска текста.

<sample-output>

?- **{family_base}.**
% [ /home/eugeneai/tmp/tst/family_base.lgt loaded ]
% (0 warnings)
true.

?- **{family_pat}.**
% [ /home/eugeneai/tmp/tst/family_pat.lgt loaded ]
% (0 warnings)
true.

?- **{family_pat_2}.**
% [ /home/eugeneai/tmp/tst/family_pat_2.lgt loaded ]
% (0 warnings)
true.

?- **family_pat_2::mother(Who, Whose).**
Who = pat,
Whose = john **;**
<b class='errLog'>false.</b>

</sample-output>

Выдается только ответы для новорожденного Джона, и ничего не выдается для Джилл, а она ж дочь Патриции и Макса!  Дело в том, что Logtalk считает, что новые реализации методлов полностью обновляют старые при наследовании.  Чтобы включить в семью информацио про ```jill```, надо послать сообщение объекту-предку.  Для этого есть третья форма посылки сообщения ```^^<метод>[(<параметры>)]```, то есть как будто бы к самому себе, только (```::/1```) заменяется на (```^^/1```).  Очевидно, что (```^^/1```) может быть только одноаргументным.  Дополним необходимыми конструкциями наш объект ```family_pat_2/0```.

```logtalk
% File: family_pat_2.lgt

:- object(family_pat_2,
      extends(family_pat)).

   man(john).
   man(Who) :-
      ^^man(Who).

   parent(pat, john).
   parent(max, john).
   parent(Who, Whose) :-
      ^^parent(Who, Whose).

:- end_object.
```

Теперь все как надо!  Все дети на месте.

<sample-output>
% Загрузка объектов family_base, family_pat . . .

?- **{family_pat_2}.**
% [ /home/eugeneai/tmp/tst/family_pat_2.lgt loaded ]
% (0 warnings)
true.

?- **family_pat_2::mother(Who, Whose).**
Who = pat,
Whose = john **;**
Who = pat,
Whose = jill **;**
<b class='errLog'>false.</b>

</sample-output>

**Замечание 1.** При добавлении вариантов реализации метода при наследовании в Logtalk необхдоимо задумываться, на кокаом этапе следует включать вызовы унаследованных частей: до, после или в середине новой реализации, надо ли вообще вызывать?

**Замечание 2.** Сообщения объектам-предкам не обязательно должны быть тлоько к таким же методам.  Logtalk никак не ограничивает какой метод потомка какой матод предка должен вызывать.

**Замечание 3.** Если заменить в последней реализации ```family_pat_2/0``` вызовы к предку (```^^/1```) на вызовы к самому себе (```::/1```), то мы получим программу, генерирующую бесконечное количество ответов, или вообще получим "зациливание", не генерирующее ни одного ответа.  Внимательно следите за своим кодом. Впрочем, Logtalk в режиме компиляции отслеживает такой код и выдает сообщение об ошибке.

Теперь на данном даже начальном этапе мы видим, в чем выразительная сила Logtalk по сравнении с Prolog, - это возможность *инкапсуляции* знаний в виде **целостных объектов** и *манимуляции* **наборами знаний** при использовании наследования, в частности.

<!--

A quiz to review the contents of this section:

<quiz id="10cb3510-d8a6-5e9b-b372-c85c4c7eb957"></quiz>

-->
