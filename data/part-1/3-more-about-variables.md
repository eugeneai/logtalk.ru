---
path: "/part-1/3-more-about-variables"
title: "Области видимости и протоколы"
hidden: false
---

<text-box variant='learningObjectives' name='Цель изучения раздела'>

В этом разделе вы узнаете, как

- Задавать область видимости методам
- Пользоваться предоставляемыми этим механизмом возможностями для создания программ
- Задавать протоколы, аналоги интерфейсов

</text-box>

Как и в большинстве современных языков объекно-ориентированного программирования в Logtalk можно задавать области видимости методам объекта.  Эти декларации Logtalk использует для контроля над  сообщениями, посылаемыми объектами друг другу.  В первом и втором разделах мы уже видели один пример, где при помощи директивы ```public/1``` задавался тот такт, что некоторые методы можно запускать "снаружи" объекта.

```logtalk
% File: list.lgt

:- object(list).

    :- public([
        append/3, length/2, member/2
    ]).

    append([], List, List).
    append([Head| Tail], List, [Head| Tail2]) :-
        append(Tail, List, Tail2).

    length(List, Length) :-
        length(List, 0, Length).

    length([], Length, Length).
    length([_| Tail], Acc, Length) :-
        Acc2 is Acc + 1,
        length(Tail, Acc2, Length).

    member(Element, [Element| _]).
    member(Element, [_| List]) :-
        member(Element, List).

:- end_object.
```

Вот так, например, делается запрос.

<sample-output>

?- **logtalk_load(list).**
object list loaded
true.

?- **list::member(X, [1, 2, 3]).**
X = 1;
X = 2;
X = 3;
false.

</sample-output>


## Область видимости

Область видимости (scope) методов, а в Logtalk у нас есть только методы (предикаты), задаются при помощи следующих директив:

<dl>
  <dt><b>private/1</b></dt>
  <dd>Метод является приватным, и его обасть видимости ограничивается объектом, где он определен. Вызвать его "снаружи" объекта невозможно.  Невозможно вызвать и из потомков-наследников. </dd>
  <dt><strong>public/1</strong></dt>
  <dd>Метод является публичным, и его область видимости никак не ограничена. Его вызывать можно из любого объекта.</dd>
  <dt><strong>protected/1</strong></dt>
  <dd>Области видимости метода включает объект, где этот метод определен, а также все объекты-потомки.</dd>
</dl>

**Замечание 1.** На самом деле, чтобы не вводить в вас заблуждение, надо сказать, что в Logtalk при наследовании также можно указать вариант наследования: ```public```, ```private``` и  ```protected```.  По умолчанию, то есть, если специально не указано, используется вариант ```public```, который не меняет области ивидимости методов.  Нследование ```private``` и ```protected``` по определенным правилам изменяют область видимости.  Здесь мы рассматриваем варианты, полагая, что все наследование осуществляется по умолчанию.

У каждой директивы только **один** параметр! В качестве него выступает либл декларация одного метода в форме ```<идентификатор>/<арность>``` (арность - это количество аргументов: 0, 1, 2, ...), либо список таких деклараций.  Директивы области видимости можно сосредотачивать и в начале объекта и рядом с реализациями их методов.  Важно не проводить редекларации области видимости в одном объекте.  Если для метода не указана деректива облати видимости, то его область видимости аналогична ```private```.  Кроме того, использование директив несколько изменяет реакцию компилятора на вызовы методов, реализации кторых не существуют.

Как известно, в ISO Prolog, если программа вызвала предикат, для которого ничего не задано (ни фактов, не правил), создается либо исключение, либо этот неопределенный предикат считается невыводимым.  Все зависит от настроек интерпретатора Пролога.  В Logtalk такое поведеине тоже регулируется специальными директивами, но и зависит от контекста.

Простой пример из предыдущего раздела, где было "забыто" использование сообщений к себе.

```logtalk
% File:family_base.lgt

:- object(family_base).
   :- public([
      man/1,    % мужчина(<кто>)
      woman/1,  % женщина(<кто>)
      parent/2, % родитель(<кто>,<чей>)
      mother/2, % отец(<кто>,<чей>)
      father/2  % мать(<кто>,<чей>)
   ]).

   mother(Who, Whose) :-
      woman(Who), % должно быть ::woman(Who)
      % аналогично, ::parent(Who, Whose).
      parent(Who, Whose).

   father(Who, Whose) :-
      man(Who),   % и здесь тоже ...
      parent(Who, Whose).

:- end_object.
```

Компилятор Logtalk видит, что ```woman/1```, ```man/1``` и ```parent/2``` обозначены директивой ```public/1```, но в объекте ```family_base/0``` они не определены.  Вызовы ```woman/1```, ```man/1``` и ```parent/2``` сделамы без ```::``` и без ```^^```, то есть, кроме как в самом объекте они нигде не могут быть определены.  Отсюда следует, что реализации ```mother/2``` и ```father/2``` либо недоделанные, либо ошибочные, в любом случае, не приведут к положительному ответу.  Видя такое обстоятельство, компилятор выводит сообщение об **ошибке** (error), даже не _предупреждение_ (warning).

## Совершенствуем систему объектов семейных отношений

Предположим нам не хочется публиковать "элементарные" (базовые) отношения о структуре семьи (```woman/1```, ```man/1``` и ```parent/2```) Патриции, и оставить только публичными ```father/2``` и ```mother/2```, при всем этом оставить возможность задания состава семьи в объектах-потомках.  На это раз все в одно файле ```family.lgt``` оформим.

```logtalk
% File:family.lgt

:- object(family_base).

   :- public([
      mother/2, % отец(<кто>,<чей>)
      father/2  % мать(<кто>,<чей>)
   ]).

   % изменение области видимости
   :- protected([
      man/1,    % мужчина(<кто>)
      woman/1,  % женщина(<кто>)
      parent/2  % родитель(<кто>,<чей>)
   ]).

   mother(Who, Whose) :-
      ::woman(Who),
      ::parent(Who, Whose).

   father(Who, Whose) :-
      ::man(Who),
      ::parent(Who, Whose).

:- end_object.

:- object(family_pat,
      extends(family_base)).

   man(max).

   woman(pat).
   woman(jill).

   parent(max, jill).
   parent(pat, jill).

:- end_object.

:- object(family_pat_2,
      extends(family_pat)).

   man(john).
   man(Who) :-
      ^^man(Who).

   parent(pat, john).
   parent(max, john).
   parent(Who, Whose) :-
      ^^parent(Who, Whose).

:- end_object.
```

Теперь Logtalk, компилируя объект ```family_base/0```, видит, что ```woman/1```, ```man/1``` и ```parent/2``` находятся в области видимостиобъекта и его потомков контролирует, чтоб их не вызывали без ```::```, понимает, что их реализация бутет осуществлена при наследовании.  Если эти три метода сделать ```private```, то Logtalk обратит внимаение, что для правильного функционирования публичных предикатов требуется реализация ```woman/1```, ```man/1``` и ```parent/2```.

Потестируем, что у нас получилось.

<sample-output>

?- **{family}.**
<b class="green">% [ /home/eugeneai/tmp/tst/family.lgt loaded ]
% (0 warnings)</b>
true.

?- **family_pat_2::mother(Who, Whose).**
Who = pat,
Whose = john **;**
Who = pat,
Whose = jill **;**
<b class="errLog">false</b>.

</sample-output>

Теперь попробуем получить доступ к базовым отношениям.


<sample-output>

?- **family_pat_2::man(Who).**
<b class="errLog">!     Permission error: access protected_predicate man/1
!       in goal: family_pat_2::man(A)
!       with execution context:
!         entity:            user
!         sender:            user
!         this:              user
!         self:              B
!         meta-call context: []
!         coinduction stack: []
!</b>

</sample-output>

Сообщение об ошибки (исключение) говорит, что мы не можем снаружи ```family_pat_2/0``` вызвать метод ```man/1```, так ка он звщищенный.  Однако в режиме отладки мы можем делать так.

<sample-output>

?- **family_pat_2<<man(Who).**
Who = john **;**
Who = max **.** % больше не нужно решений

</sample-output>

Здесь использется специальный вид оператора посылки сообщений ```<</2```, называемый вызовом метода с переключением контекста.  В данном случае переключается контекст с объекта, осуществляющего вызов, *source object*, ```user``` (иногда ```logtalk```), на ```family_pat_2/0```, *target object* (вызываемый объект) после чего, собственно, посылается сообщение.  Этот инструмент разрешается использовать только для отладки в ```top_level/0``` (комендная строка Prolog/Logtalk) или при реализации тестов.  В программах его использование запрещено.

При загрузке программы из командной строки Prolog включены все возможности для осуществления отладки программы.  Запуск программы по ее основному предназначению по умлочанию осуществляется с  отключеными средствами отладки, отключен, соответственно, и режим посылки сообщений с переключением контекста.  Реализация тестов может потребовать данные инструменты отладки, и чтобы их включить, надо установить флаг ```context_switching_calls``` в значений ```allow```:

```logtalk
:- set_logtalk_flag(context_switching_calls, allow).
```

## Определение протокола списка

Совокупность директив (```private/1```, ```protected/1```, ```public/1```) задания _области ивдимости имен_ (_scope_) для предикатов определяет то, что мы называем _протоколом_ (_protocol_) объектов или интерфейсом.  Интерфейс может иметь несколько реализаций. Например, мы можем захотеть определить новый объект, который реализует предикаты списка, используя другой подход, например разностное представление.  При этом мы не хотим повторять директивы задания пространства имен заново в новом объекте.  Нам удобно было б отделить определения методов от их реализации в объекте.  Для этого в Logtalk существет вариант объекта, известный как _протокол_. Протоколы Logtalk представляют собой элементы компиляции, равноправные с объектами и так называемыми категориями.

Давайте вернемся к примеру с инкапсуляцией предикатов облаботки списков в объекте ```list``` и определим протокол листинга.  Удобно называть протоколы идентификаторами с буквой "```p```" на конце:

```logtalk
% File: listp.lgt

:- protocol(listp).

   :- public([
         append/3, length/2, member/2
     ]).

:- end_protocol.
```

Размещение в файлах протоколов делается аналогично объектам - берем название протокола ```listp``` и добавляем к нему суффикс ```.ltg```, получаем ```listp.lgt```.

Теперь изменим наше определение объекта списка ```list/0```, удалив директивы предикатов и объявив, что объект реализует протокол ```listp``` (протоколы будем обозначать без арности).

```logtalk
:- object(list,
    implements(listp)).  % объявление соответствия
                         % протоколу listp

    % реализация одного из заявленных методлов
    append([], List, List).
    append([Head| Tail], List, [Head| Tail2]) :-
        append(Tail, List, Tail2).

    % . . . . . . .

:- end_object.
```

Протокол, объявленный в листинге, теперь может быть альтернативно реализован с использованием списков отличий путем определения нового объекта, разностного представления списка (difference list representation).

```logtalk
% File: difflist.lgt

:- object(difflist,
    implements(listp).

    append(L1-X, X-L2, L1-L2).
    % . . . . . . .

:- end_object.
```

## Документирование объектов

При разработке больших проектов документирование компонентов (в широком смысле) является не обходимым видом дейтельности разработчиков.  В отличие от большинства языков программирования и благодаря абстрактному синтаксису и семантике языка Prolog/Logtalk, описание структуры объекта, включая протоколы, реализуется на самом языке без использования каких-либо расширений синтаксиса и интерпретации сообщений в комментариях.  Например в следущем примере протокол ```listp``` доработан, здесь для каждого метода представлены варианты передачи параметров в методы, а также каким образом он выдает ответы.

```logtalk
% File: listp.lgt

:- protocol(listp).

    :- public(append/3).
    :- mode(append(?list, ?list, ?list), zero_or_more).

    :- public(length/2).
    :- mode(length(?list, ?integer), zero_or_more).

    :- public(member/2).
    :- mode(member(?term, ?list), zero_or_more).

:- end_protocol.
```

Директива ```mode/2``` включает два параметра.  Первый - спецификация структуры сообщения.  Вторая часть задает как функционирует метод, сколько выдает ответов.  В данном случае ```zero_or_more``` обозначает, что все методы в самом общем случае либо не выдают положительного ответа (```zero```), либо выдают множество ответов (```_or_more```).

В спецификации структуры сообщения представлен сам метод: его идентификатор и аргументы.  Для каждого аргумента указывается тип данных и знак, обозначающий входным ("-"), выходным ("+") или и тем и другим ("?") будет аргумент.

**Замечание 2.** На самом деле в Prolog, и, следовательно, в Logtalk, знак "-" означает, что в качестве аргумента передается свободная переменная.  Знак "+" соответствует аргументу, который должен быть основным термом, а "?" обозначает, что и первый и второй вариант возможны, также как и термы, содержащие переменные.  В большинстве реализаций Prolog знаки указываются в комментарии, например так.

```prolog
% Вычисление факториала
%    +  ?
fact(0, 1):-!.
fact(1, 1):-!.
fact(N, M):-
    N1 is N-1,
    fact(N1, M1),
    M is M1*N.
```

Далее по ходу изучения курса мы познакомися с другими директивами, позволяющими описывать структуру объектов.

<!--

A quiz to review the contents of this section:

<quiz id="49bf296e-41d1-5982-89a9-c784b630eaee"></quiz>

-->
