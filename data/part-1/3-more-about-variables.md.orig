---
path: "/part-1/3-more-about-variables"
<<<<<<< HEAD
title: "Области видимости и протоколы"
hidden: false
---

<text-box variant='learningObjectives' name='Цель изучения раздела'>

В этом разделе вы узнаете, как

- Задавать область видимости методам
- Пользоваться предоставляемыми этим механизмом возможностями для создания программ
- Задавать протоколы, аналоги интерфейсов

</text-box>

Как и в большинстве современных языков объекно-ориентированного программирования в Logtalk можно задавать области видимости методам объекта.  Эти декларации Logtalk использует для контроля над  сообщениями, посылаемыми объектами друг другу.  В первом и втором разделах мы уже видели один пример, где при помощи директивы ```public/1``` задавался тот такт, что некоторые методы можно запускать "снаружи" объекта.

```logtalk
% File: list.lgt

:- object(list).

    :- public([
        append/3, length/2, member/2
    ]).

    append([], List, List).
    append([Head| Tail], List, [Head| Tail2]) :-
        append(Tail, List, Tail2).

    length(List, Length) :-
        length(List, 0, Length).

    length([], Length, Length).
    length([_| Tail], Acc, Length) :-
        Acc2 is Acc + 1,
        length(Tail, Acc2, Length).

    member(Element, [Element| _]).
    member(Element, [_| List]) :-
        member(Element, List).

:- end_object.
```

Вот так, например, делается запрос.

<sample-output>

?- **logtalk_load(list).**
object list loaded
true.

?- **list::member(X, [1, 2, 3]).**
X = 1;
X = 2;
X = 3;
false.

</sample-output>


## Область видимости

Область видимости (scope) методов, а в Logtalk у нас есть только методы (предикаты), задаются при помощи следующих директив:

<dl>
  <dt><b>private/1</b></dt>
  <dd>Метод является приватным, и его обасть видимости ограничивается объектом, где он определен. Вызвать его "снаружи" объекта невозможно.  Невозможно вызвать и из потомков-наследников. </dd>
  <dt><strong>public/1</strong></dt>
  <dd>Метод является публичным, и его область видимости никак не ограничена. Его вызывать можно из любого объекта.</dd>
  <dt><strong>protected/1</strong></dt>
  <dd>Области видимости метода включает объект, где этот метод определен, а также все объекты-потомки.</dd>
</dl>

**Замечание 1.** На самом деле, чтобы не вводить в вас заблуждение, надо сказать, что в Logtalk при наследовании также можно указать вариант наследования: ```public```, ```private``` и  ```protected```.  По умолчанию, то есть, если специально не указано, используется вариант ```public```, который не меняет области ивидимости методов.  Нследование ```private``` и ```protected``` по определенным правилам изменяют область видимости.  Здесь мы рассматриваем варианты, полагая, что все наследование осуществляется по умолчанию.

У каждой директивы только **один** параметр! В качестве него выступает либл декларация одного метода в форме ```<идентификатор>/<арность>``` (арность - это количество аргументов: 0, 1, 2, ...), либо список таких деклараций.  Директивы области видимости можно сосредотачивать и в начале объекта и рядом с реализациями их методов.  Важно не проводить редекларации области видимости в одном объекте.  Если для метода не указана деректива облати видимости, то его область видимости аналогична ```private```.  Кроме того, использование директив несколько изменяет реакцию компилятора на вызовы методов, реализации кторых не существуют.

Как известно, в ISO Prolog, если программа вызвала предикат, для которого ничего не задано (ни фактов, не правил), создается либо исключение, либо этот неопределенный предикат считается невыводимым.  Все зависит от настроек интерпретатора Пролога.  В Logtalk такое поведеине тоже регулируется специальными директивами, но и зависит от контекста.

Простой пример из предыдущего раздела, где было "забыто" использование сообщений к себе.

```logtalk
% File:family_base.lgt

:- object(family_base).
   :- public([
      man/1,    % мужчина(<кто>)
      woman/1,  % женщина(<кто>)
      parent/2, % родитель(<кто>,<чей>)
      mother/2, % отец(<кто>,<чей>)
      father/2  % мать(<кто>,<чей>)
   ]).

   mother(Who, Whose) :-
      woman(Who), % должно быть ::woman(Who)
      % аналогично, ::parent(Who, Whose).
      parent(Who, Whose).

   father(Who, Whose) :-
      man(Who),   % и здесь тоже ...
      parent(Who, Whose).

:- end_object.
```

Компилятор Logtalk видит, что ```woman/1```, ```man/1``` и ```parent/2``` обозначены директивой ```public/1```, но в объекте ```family_base/0``` они не определены.  Вызовы ```woman/1```, ```man/1``` и ```parent/2``` сделамы без ```::``` и без ```^^```, то есть, кроме как в самом объекте они нигде не могут быть определены.  Отсюда следует, что реализации ```mother/2``` и ```father/2``` либо недоделанные, либо ошибочные, в любом случае, не приведут к положительному ответу.  Видя такое обстоятельство, компилятор выводит сообщение об **ошибке** (error), даже не _предупреждение_ (warning).

## Совершенствуем систему объектов семейных отношений

Предположим нам не хочется публиковать "элементарные" (базовые) отношения о структуре семьи (```woman/1```, ```man/1``` и ```parent/2```) Патриции, и оставить только публичными ```father/2``` и ```mother/2```, при всем этом оставить возможность задания состава семьи в объектах-потомках.  На это раз все в одно файле ```family.lgt``` оформим.

```logtalk
% File:family.lgt

:- object(family_base).

   :- public([
      mother/2, % отец(<кто>,<чей>)
      father/2  % мать(<кто>,<чей>)
   ]).

   % изменение области видимости
   :- protected([
      man/1,    % мужчина(<кто>)
      woman/1,  % женщина(<кто>)
      parent/2  % родитель(<кто>,<чей>)
   ]).

   mother(Who, Whose) :-
      ::woman(Who),
      ::parent(Who, Whose).

   father(Who, Whose) :-
      ::man(Who),
      ::parent(Who, Whose).

:- end_object.

:- object(family_pat,
      extends(family_base)).

   man(max).

   woman(pat).
   woman(jill).

   parent(max, jill).
   parent(pat, jill).

:- end_object.

:- object(family_pat_2,
      extends(family_pat)).

   man(john).
   man(Who) :-
      ^^man(Who).

   parent(pat, john).
   parent(max, john).
   parent(Who, Whose) :-
      ^^parent(Who, Whose).

:- end_object.
```

Теперь Logtalk, компилируя объект ```family_base/0```, видит, что ```woman/1```, ```man/1``` и ```parent/2``` находятся в области видимостиобъекта и его потомков контролирует, чтоб их не вызывали без ```::```, понимает, что их реализация бутет осуществлена при наследовании.  Если эти три метода сделать ```private```, то Logtalk обратит внимаение, что для правильного функционирования публичных предикатов требуется реализация ```woman/1```, ```man/1``` и ```parent/2```.

Потестируем, что у нас получилось.

<sample-output>

?- **{family}.**
<b class="green">% [ /home/eugeneai/tmp/tst/family.lgt loaded ]
% (0 warnings)</b>
true.

?- **family_pat_2::mother(Who, Whose).**
Who = pat,
Whose = john **;**
Who = pat,
Whose = jill **;**
<b class="errLog">false</b>.

</sample-output>

Теперь попробуем получить доступ к базовым отношениям.


<sample-output>

?- **family_pat_2::man(Who).**
<b class="errLog">!     Permission error: access protected_predicate man/1
!       in goal: family_pat_2::man(A)
!       with execution context:
!         entity:            user
!         sender:            user
!         this:              user
!         self:              B
!         meta-call context: []
!         coinduction stack: []
!</b>

</sample-output>

Сообщение об ошибки (исключение) говорит, что мы не можем снаружи ```family_pat_2/0``` вызвать метод ```man/1```, так ка он звщищенный.  Однако в режиме отладки мы можем делать так.

<sample-output>

?- **family_pat_2<<man(Who).**
Who = john **;**
Who = max **.** % больше не нужно решений

</sample-output>

Здесь использется специальный вид оператора посылки сообщений ```<</2```, называемый вызовом метода с переключением контекста.  В данном случае переключается контекст с объекта, осуществляющего вызов, *source object*, ```user``` (иногда ```logtalk```), на ```family_pat_2/0```, *target object* (вызываемый объект) после чего, собственно, посылается сообщение.  Этот инструмент разрешается использовать только для отладки в ```top_level/0``` (комендная строка Prolog/Logtalk) или при реализации тестов.  В программах его использование запрещено.

При загрузке программы из командной строки Prolog включены все возможности для осуществления отладки программы.  Запуск программы по ее основному предназначению по умлочанию осуществляется с  отключеными средствами отладки, отключен, соответственно, и режим посылки сообщений с переключением контекста.  Реализация тестов может потребовать данные инструменты отладки, и чтобы их включить, надо установить флаг ```context_switching_calls``` в значений ```allow```:

```logtalk
:- set_logtalk_flag(context_switching_calls, allow).
```

## Определение протокола списка

Совокупность директив (```private/1```, ```protected/1```, ```public/1```) задания _области ивдимости имен_ (_scope_) для предикатов определяет то, что мы называем _протоколом_ (_protocol_) объектов или интерфейсом.  Интерфейс может иметь несколько реализаций. Например, мы можем захотеть определить новый объект, который реализует предикаты списка, используя другой подход, например разностное представление.  При этом мы не хотим повторять директивы задания пространства имен заново в новом объекте.  Нам удобно было б отделить определения методов от их реализации в объекте.  Для этого в Logtalk существет вариант объекта, известный как _протокол_. Протоколы Logtalk представляют собой элементы компиляции, равноправные с объектами и так называемыми категориями.

Давайте вернемся к примеру с инкапсуляцией предикатов облаботки списков в объекте ```list``` и определим протокол листинга.  Удобно называть протоколы идентификаторами с буквой "```p```" на конце:

```logtalk
% File: listp.lgt

:- protocol(listp).

   :- public([
         append/3, length/2, member/2
     ]).

:- end_protocol.
```

Размещение в файлах протоколов делается аналогично объектам - берем название протокола ```listp``` и добавляем к нему суффикс ```.ltg```, получаем ```listp.lgt```.

Теперь изменим наше определение объекта списка ```list/0```, удалив директивы предикатов и объявив, что объект реализует протокол ```listp``` (протоколы будем обозначать без арности).

```logtalk
:- object(list,
    implements(listp)).  % объявление соответствия
                         % протоколу listp

    % реализация одного из заявленных методлов
    append([], List, List).
    append([Head| Tail], List, [Head| Tail2]) :-
        append(Tail, List, Tail2).

    % . . . . . . .

:- end_object.
```

Протокол, объявленный в листинге, теперь может быть альтернативно реализован с использованием списков отличий путем определения нового объекта, разностного представления списка (difference list representation).

```logtalk
% File: difflist.lgt

:- object(difflist,
    implements(listp).

    append(L1-X, X-L2, L1-L2).
    % . . . . . . .

:- end_object.
```

## Документирование объектов

При разработке больших проектов документирование компонентов (в широком смысле) является не обходимым видом дейтельности разработчиков.  В отличие от большинства языков программирования и благодаря абстрактному синтаксису и семантике языка Prolog/Logtalk, описание структуры объекта, включая протоколы, реализуется на самом языке без использования каких-либо расширений синтаксиса и интерпретации сообщений в комментариях.  Например в следущем примере протокол ```listp``` доработан, здесь для каждого метода представлены варианты передачи параметров в методы, а также каким образом он выдает ответы.

```logtalk
% File: listp.lgt

:- protocol(listp).

    :- public(append/3).
    :- mode(append(?list, ?list, ?list), zero_or_more).

    :- public(length/2).
    :- mode(length(?list, ?integer), zero_or_more).

    :- public(member/2).
    :- mode(member(?term, ?list), zero_or_more).

:- end_protocol.
```

Директива ```mode/2``` включает два параметра.  Первый - спецификация структуры сообщения.  Вторая часть задает как функционирует метод, сколько выдает ответов.  В данном случае ```zero_or_more``` обозначает, что все методы в самом общем случае либо не выдают положительного ответа (```zero```), либо выдают множество ответов (```_or_more```).

В спецификации структуры сообщения представлен сам метод: его идентификатор и аргументы.  Для каждого аргумента указывается тип данных и знак, обозначающий входным ("-"), выходным ("+") или и тем и другим ("?") будет аргумент.

**Замечание 2.** На самом деле в Prolog, и, следовательно, в Logtalk, знак "-" означает, что в качестве аргумента передается свободная переменная.  Знак "+" соответствует аргументу, который должен быть основным термом, а "?" обозначает, что и первый и второй вариант возможны, также как и термы, содержащие переменные.  В большинстве реализаций Prolog знаки указываются в комментарии, например так.

```prolog
% Вычисление факториала
%    +  ?
fact(0, 1):-!.
fact(1, 1):-!.
fact(N, M):-
    N1 is N-1,
    fact(N1, M1),
    M is M1*N.
```

Далее по ходу изучения курса мы познакомися с другими директивами, позволяющими описывать структуру объектов.
=======
title: "More about variables"
hidden: false
---

<text-box variant='learningObjectives' name='Learning objectives'>

After this section

- You will be able to use variables in different contexts
- You will know what kind of data can be stored in variables
- You will understand the difference between strings, integers and floating point numbers

</text-box>

Please fill in this questionnaire before getting started with this section. You will get one exercise point for answering.

<quiz id="5f930565-c71e-50cc-89f2-eb410d7b8a9d"></quiz>



Variables are needed for various purposes in programming. You can use variables to store any information that will be needed later in the program's execution.

In Python programming variables are created like so:

`variable_name = ...`

Here `...` means the value stored in the variable.

For example, when you used the `input` command to read a string from the user, you stored the string in a variable and then used the variable later in your program:

```python
name = input("What is your name? ")
print("Hi, " + name)
```

<sample-output>

What is your name? **Ghosty**
Hi, Ghosty

</sample-output>

The value stored in a variable can also be defined using other variables:

```python
given_name = "Paul"
family_name = "Python"

name = given_name + " " + family_name

print(name)
```

<sample-output>

Paul Python

</sample-output>

Here the values stored in the three variables are not obtained from user input. They remain the same every time the program is executed. This is called _hard-coding_ data into the program.

## Changing the value of a variable

As implied by the name _variable_, the value stored in a variable can change. In the previous section we noticed that the new value replaces the old one.

During the execution of the following program, the variable `word` will have three different values:

```python
word = input("Please type in a word: ")
print(word)

word = input("And another word: ")
print(word)

word = "third"
print(word)
```

<sample-output>

Please type in a word: **first**
first
And another word: **second**
second
third

</sample-output>

The value stored in the variable changes each time the variable is assigned a new value.

The new value of a variable can be derived from its old value. In the following example the variable `word` is first assigned a value based on user input. Then it is assigned a new value, which is the old value with three exclamation marks added to the end.

```python
word = input("Please type in a word: ")
print(word)

word = word + "!!!"
print(word)
```

<sample-output>

Please type in a word: **test**
test
test!!!

</sample-output>

<text-box variant="hint" name="Choosing a good name for a variable">

* It is often useful to name variables according to what they are used for. For example, if the variable contains a word, the name `word` is a better choice than, say, `a`.

* There is no set limit to the length of a variable name in Python, but there are some other limitations. A variable name should begin with a letter, and it can only contain letters, numbers and underscores &#95;.

* Lowercase and uppercase letters are different characters. The variables `name`, `Name` and `NAME` are all different variables. While this rule has a few exceptions, we will ignore those for now.

* It is a common programming practice in Python to use only lowercase characters in variable names. If the variable name consists of multiple words, use an underscore between the words. While this rule also has a few exceptions, we will ignore those for now.

</text-box>

## Integers

Thus far, we have only stored strings in variables, but there are also many other types of information we will want to store and access later. Let's have a look at integers first. Integers are numbers that do not have a decimal or fractional part, such as `-15`, `0` and `1`.

The following program creates the variable `age`, which contains an integer value.

```python
age = 24
print(age)
```

The program prints out just this:

<sample-output>

24

</sample-output>

Notice the lack of quotation marks here. In fact, if we were to add quotation marks around the number, this would mean our variable would no longer be an integer, but a string instead. A string can contain numbers, but it is processed differently.

So, why does it matter that variables have a type, when the following program still prints out the same thing twice?

```python
number1 = 100
number2 = "100"

print(number1)
print(number2)
```

<sample-output>

100
100

</sample-output>

Variable types matter because different operations affect different types of variables in different ways. Let's have a look at an example:

```python
number1 = 100
number2 = "100"

print(number1 + number1)
print(number2 + number2)
```

This prints out the following:

<sample-output>

200
100100

</sample-output>

For integer values the `+` operator means addition, but for string values it means concatenation, or "stringing together".

Not all operators are available for all types of variables. While numbers can be divided using the division operator `/`, attempting to divide a string by a number causes an error:

```python
number = "100"
print(number / 2)
```

<sample-output>
TypeError: unsupported operand type(s) for /: 'str' and 'int'
</sample-output>

## Combining values when printing

Similarly, the following program will not work, because `"The result is "` and `result` are of two different types:

```python
result = 10 * 25
# the following line produces an error
print("The result is " + result)
```

The program does not print out anything, but instead throws an error:

<sample-output>

TypeError: unsupported operand type(s) for +: 'str' and 'int'

</sample-output>

Here, Python tells us that combining two different types of values will not work just like that. In this case, `"The result is "` is of type string, while the value stored in `result` is of type integer.

If we do want to print out a string and an integer in a single command, the integer can be cast as a string with the `str` function, and the two strings can then be combined normally. For example, this would work:

```python
result = 10 * 25
print("The result is " + str(result))
```

<sample-output>

The result is 250

</sample-output>

The `print` command also has built-in functionalities that support combining different types of values. The simplest way is to add a comma between the values. All the values will be printed out regardless of their type:

```python
result = 10 * 25
print("The result is", result)
```

<sample-output>

The result is 250

</sample-output>

Notice that there is an automatically added whitespace character between the values separated by a comma here.

## Printing with f-strings

What if we want to have more flexibility and control over what we print out? So called _f-strings_ are another way of formatting printouts in Python. The syntax can initially look a bit confusing, but in the end f-strings are often the simplest way of formatting text.

With f-strings the previous example would look like this:

```python
result = 10 * 25
print(f"The result is {result}")
```

Let's break this apart. In the very beginning of the string we are printing out there is the character _f_. This tells Python that what follows is an f-string. Within the string, enclosed in curly brackets, is the variable name `result`. The value it contains becomes a part of the printed string. The printout is exactly the same as in the previous examples:

<sample-output>

The result is 250

</sample-output>

A single f-string can contain multiple variables. For example this code

```python
name = "Mark"
age = 37
city = "Palo Alto"
print(f"Hi {name}, you are {age} years old. You live in {city}.")
```

prints out this:

<sample-output>

Hi Mark, you are 37 years old. You live in Palo Alto.

</sample-output>

It is difficult to create a printout exactly like this using the comma notation in the `print` command. For example, this program

```python
name = "Mark"
age = 37
city = "Palo Alto"
print("Hi", name, ", you are", age, "years old. You live in", city, ".")
```

prints out the following:

<sample-output>

Hi Mark , you are 37 years old. You live in Palo Alto .

</sample-output>

Notice the automatically inserted whitespace between each comma-separated part of the printout. Preventing `print` from adding the extra spaces is technically possible, but not worth the trouble given that we can instead use f-strings.

In its simplicity the comma notation of the `print` command can often be useful, but it does sometimes cause more trouble than it's worth. F-strings are usually a more reliable option. In part 4 you will learn more about the handy features of f-strings when it comes to formatting printouts.

<text-box variant="hint" name="F-strings and Python versions">

If you are using an older version of Python, f-strings may not work. They were introduced in Python version 3.6. Later on during the course you will install Python on your own computer. Unfortunately, the more modern versions of Python are not always available for older operating systems. If that is the case with your computer, when there are exercises requiring the use of f-strings, you can always try them out in the in-browser exercise templates in these early parts of this course.

</text-box>

<in-browser-programming-exercise name="Extra space" tmcname="part01-10b_extra_space" height=400px>

Your friend is working on an app for jobseekers. She sends you this bit of code:

```python
name = "Tim Tester"
age = 20
skill1 = "python"
level1 = "beginner"
skill2 = "java"
level2 = "veteran"
skill3 = "programming"
level3 = "semiprofessional"
lower = 2000
upper = 3000

print("my name is ", name, " , I am ", age, "years old")
print("my skills are")
print("- ", skill1, " (", level1, ")")
print("- ", skill2, " (", level2, ")")
print("- ", skill3, " (", level3, " )")
print("I am looking for a job with a salary of", lower, "-", upper, "euros per month")
```

The program should print out _exactly_ the following:

<sample-output>

<pre>
my name is Tim Tester, I am 20 years old

my skills are
 - python (beginner)
 - java (veteran)
 - programming (semiprofessional)

I am looking for a job with a salary of 2000-3000 euros per month
</pre>

</sample-output>

The code works almost correctly, but not quite. This exercise has very strict tests, which check the output for every single bit of whitespace.

Please fix the code so that the printout looks right. Notice especially how the comma notation in the `print` command automatically inserts a space around the different comma-separated parts.

The easiest way to transform the code so that it meets requirements is to use f-strings.

Hint: you can print an empty line by adding an empty `print` command, or by adding the newline character `\n` into your string.

Do remember to be extra careful when formatting printouts also in the future on this course. Some of the exercises have tests that require your output to be exactly as specified in the examples given. For example, please use actual whitespace characters in your code, instead of ASCII character codes for whitespace, or some such.

</in-browser-programming-exercise>

## Floating point numbers

`Floating point number` or _float_ is a term you will come across often in programming. It refers to numbers with a decimal point. They can be used much in the same way as integer values.

This program calculates the mean of three floating point numbers:

```python
number1 = 2.5
number2 = -1.25
number3 = 3.62

mean = (number1 + number2 + number3) / 3
print(f"Mean: {mean}")
```

<sample-output>

Mean: 1.6233333333333333

</sample-output>

<in-browser-programming-exercise name="Arithmetics" tmcname="part01-11_arithmetics">

This program already contains two integer variables, `x` and `y`:

```python
x = 27
y = 15
```

Please complete the program so that it also prints out the following:

<sample-output>

27 + 15 = 42
27 - 15 = 12
27 * 15 = 405
27 / 15 = 1.8

</sample-output>

The program should work correctly even if the values of the variables are changed. That is, if the first two lines are replaced with this

```python
x = 4
y = 9
```

the program should print out the following:

<sample-output>

4 + 9 = 13
4 - 9 = -5
4 * 9 = 36
4 / 9 = 0.4444444444444444

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Fix the code: Print a single line" tmcname="part01-12_print_a_single_line">

Each `print` command usually prints out a line of its own, complete with a change of line at the end. However, if the `print` command is given an additional argument `end = ""`, it will not print a line change.

For example:

```python
print("Hi ", end="")
print("there!")
```

<sample-output>

Hi there!

</sample-output>

Please fix this program so that the entire calculation, complete with result, is printed out on a single line. Do not change the number of `print` commands used.

```python

print(5)
print(" + ")
print(8)
print(" - ")
print(4)
print(" = ")
print(5 + 8 - 4)
```

</in-browser-programming-exercise>
>>>>>>> a71c56cac4ff2b90f0478112977423c8593e1589

<!--

A quiz to review the contents of this section:

<quiz id="49bf296e-41d1-5982-89a9-c784b630eaee"></quiz>

-->
