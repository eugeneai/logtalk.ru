---
path: '/part-1/1-getting-started'
title: 'Первый шаг'
hidden: false
---

<text-box variant='learningObjectives' name='Цель раздела'>

После изучения материала этого раздела Вы

- Напишите и выполните свою первую программу на Logtalk
- Узнаете, как реализовывать инкапсуляцию в этом языке в виде объекта
- Выполните несколько запросов к методам этого объекта

</text-box>

Основной целью создания объектов в Logtalk является инкапсуляция и повторное использование предикатов. Вместо одного общего текста, содержащего весь код, общей базы данных фактов, объекты Logtalk предоставляют отдельные пространства имен и баз данных.  Объекты позволяют делить код на части, которыми проще манипулировать. Logtalk является декларативным языком программирования и не стремится привнести какую-то новую концепцию динамического изменения состояния в парадигму логического программирования, в частности, язык Пролог.

Программа на языке Logtalk в классическом смысле представляет собой логическую теорию, статичная по своей природе.  То есть, в идеале, можно представить себе набор объектов, задающих логическую модель предметной области, посылающих друг другу сообщения с целью выяснения, истинен или ложен некоторый запрос в этой теории. Однако, как мы далее убедимся, не обязательно оставаться в таком статическом мире.

Давайте начнем процесс программирования, ознакомимся с командой «печати», которая _печатает_ на экран текст. В этом контексте (примере) печать по существу означает, что программа покажет какой-то текст на экране.

```logtalk
% File: hello.lgt

:- object(printing_object).

   :- public(print/1).

   print(Message) :-
     format('~w\n', [Message]).

:- end_object.
```

Чтобы запустить эту программу, надо загрузить ее при помощи ```{<название программы>}```, например, ```{hello}``` (Файл с программой называется ```hello.lgt```) и выполнить запрос. Вот пример интерактивного взаимодействия:

<sample-output>

$ swilgt
. . . . . . . . . . .
Welcome to SWI-Prolog (threaded, 64 bits, version 9.2.9)
SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
Please run ?- license. for legal details.

For online help and background, visit https://www.swi-prolog.org
For built-in help, use ?- help(Topic). or ?- apropos(Word).

?- **{hello}**.
% [ hello.lgt loaded ]
% (0 warnings)
true.

?- **printing_object::print('Hi there!').**
Hi there!
true.

?-

</sample-output>

Программа не будет работать, если код не написан точно так, как указано выше. Например, попытка запустить команду печати без кавычек, как

<sample-output>

?- **printing_object::print(Hi there!).**

</sample-output>


не распечатывает сообщение, а вместо этого вызывает ошибку:


<sample-output>

?- **printing_object::print(Hi there!).**
ERROR: Syntax error: Operator expected
ERROR: ?- printing_object::print(Hi
ERROR: ** here **
ERROR:  there!) .

</sample-output>

Если вы хотите распечатать текст, текст должен быть заключен в одинарные или двойные кавычки,
иначе Logtalk не будет правильно интерпретировать его.

Logtalk имеет очень развитую систему обработки ошибок и на этапе компиляции и на этапе исполнения программы. Будем с ней знакомиться в процессе изучения материала.

## Создание объекта-инкапсуляции

Основная тема в объекном-ориентированном программировании - это *инкапсуляция*.  В Logtalk она реализуется в сравнении с другими структурами проще всего.  При этом, обращаю внимание на то, что простейшие объекты не обязаны принадлежать какой-либо объектной иерархии.  Рассмотрим пример инкапсуляции некоторого набора предикатов обработки списков в одном объекте.

```logtalk
% File: list.lgt

:- object(list).

    :- public([
        append/3, length/2, member/2
    ]).

    append([], List, List).
    append([Head| Tail], List, [Head| Tail2]) :-
        append(Tail, List, Tail2).

    length(List, Length) :-
        length(List, 0, Length).

    length([], Length, Length).
    length([_| Tail], Acc, Length) :-
        Acc2 is Acc + 1,
        length(Tail, Acc2, Length).

    member(Element, [Element| _]).
    member(Element, [_| List]) :-
        member(Element, List).

:- end_object.
```

Чем это отличается от обычной программы Prolog? Определения предикатов списка являются обычными. У нас есть две новые директивы, ```object/1-5``` (```object``` с один, двумя, ... или пятью аргументами) и ```end_object/0``` (```end_object``` без аргументов).  При помощи этих директив определяется объект ```list```, который инкапсулирует код предикатов. Можно также говорить, что эти директивы *инкапсулируют* код объекта.  В Logtalk, по умолчанию, все предикаты объектов являются приватными (```private```), поэтому необходимо прямо объявить все предикаты, которые должны быть публичными, то есть, они должны в каком-то смысле вызваться "снаружи" объекта. Это делается с помощью директивы ```public/1```.

После того, как программный код объектна помещен в текстовый файл с именем ```list.lgt```, нам нужно изменить рабочий каталог Prolog на тот, который использовался для сохранения нашего файла (проконсультируйтесь со справочником компилятора Prolog). Затем, после запуска Logtalk, можно компилировать и загрузить объект с помощью встроенного предиката ```logtalk_load/1``` Logtalk:

<sample-output>

| ?- **logtalk_load(list).**

object list loaded
true.

</sample-output>

Теперь можно позапускать запросы.

<sample-output>

?- list::member(X, [1, 2, 3]).

X = 1**;** % нажимаем ";" для получения нового ответа
X = 2**;**
X = 3**;**
false.

</sample-output>

Или вот еще один вариант запроса.

<sample-output>

?- **list::length([1, 2, 3], L).**

L = 3 % нажата клавиша "Enter", что означает отказ
yes   % от новых решений

</sample-output>

Инфиксный оператор (::)/2 используется в Logtalk для отправки сообщений объекту, то есть вызов метода объекта с передачей требуемых параметров.  В Logtalk методами являются исключительно предикаты или операторы.  Имя сообщения должно соответствовать одному из публичных (public) методов (предикатов) объекта.  Если попытаться назвать непубличный метод, такой как вспомогательный предикат ```length/3```, будет создано исключение:

<sample-output>

?- **list::length([1, 2, 3], 0, L).**

uncaught exception:
    error(
        existence_error(predicate_declaration, length/3),
        logtalk(list::length([1,2,3],0,_), ...)
    )

</sample-output>

Терм исключения описывает тип ошибки и контекст, в котором она произошла.  Из курса логики мы знаем, что *терм* (*term*) - это структура, обозначающая некоторый объект.  В данном случае терм ```error/2``` описывает исключение: ```existence_error/2``` - описание исключения, состоящее из ```predicate_decoration```, обозначающее, что имеет место противоречие с декларацией предиката ```length/3```, и ```logtalk/1-``` - источник исключения, здесь это вызов метода (сообщение) ```list::length([1,2,3],0,_)```.

На самом деле вариант исключения, приведенный выше соответствует ранней версии Logtalk, работающей совместно с интерпретатором ```gnuprolog```.  Вариант для одного из свежих версий Logtalk, надстроенный над SWI-Prolog выдаст такой вариант ошибки.  Текст выдачи ошибки окрашен в красный цвет.

<sample-output>

?- **list::length([1, 2, 3], 0, L).**
<b class='errLog'>!     Existence error: predicate_declaration length/3 does not exist
!       in goal: list::length([1,2,3],0,A)
!       with execution context:
!         entity:            user
!         sender:            user
!         this:              user
!         self:              B
!         meta-call context: []
!         coinduction stack: []
!</b>

</sample-output>

Здесь сообщение более информативно, в том числе показано, откуда осуществлен вызов (```sender: user```).  Остальные значения тут не так очевидны для интерпретации, разберемся с ними позже.

## Использование комментариев

Любая строка, начинающаяся со знака «%», является комментарием. Любой текст в этой строке, следующий за символом %, никоим образом не повлияет на работу программы.  Logtalk и Prolog просто игнорирует этот текст до конца строки.  В вышериведенных примерах использованные комментарии показывают название файла, где сохраняется исходный код и действия пользователя при подаче команды запуска запроса и использования полученных результатов.

Используя комментарии, объясним структуру объекта ```list```.

```logtalk
% File: list.lgt

:- object(list). % Начало определения объекта list

    % Задание области видимости (scope) методов
    :- public([  % список рубличных методов
        append/3, length/2, member/2
    ]).

    % собственно реализация методов
    append([], List, List). % что-то вроде факта.
    % правило
    append([Head| Tail], List, [Head| Tail2]) :-
        append(Tail, List, Tail2).

    % задание [публичного] метода length/2
    length(List, Length) :-
        length(List, 0, Length).

    % задание [приватного] метода length/3
    length([], Length, Length).
    length([_| Tail], Acc, Length) :-
        Acc2 is Acc + 1,
        length(Tail, Acc2, Length).

    % [публичный] метод member/3
    member(Element, [Element| _]).
    member(Element, [_| List]) :-
        member(Element, List).

:- end_object.
```

Напомним также, что в Prolog и Logtalk названия предикатов учитывают количество аргументов, т.е. одного имени ```member``` в общем случае только часть идентификатора ```member/3```. Аналогично, название нашего объекта ```list``` должно быть ```list/0```.


<!--

A quiz to review the contents of this section:

<quiz id="f1d6d205-dfd6-5c6f-b148-b332dfd64289"></quiz>

-->
