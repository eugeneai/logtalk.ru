---
path: '/part-3/1-parametric-objects'
title: 'Параметризованные объекты'
hidden: false
---

<text-box variant='learningObjectives' name="Цель познания данного раздела">

После изучения этого раздела вы освоите

- Создание параматризованных объектов - эффективного способа предоставления методам объекта общего контекста
- Разработку методов с использованием параметров объекта
- Использование так называемых *переменных-параметров* для упрощения реализации параметрических объектов

</text-box>

*Параметрические*, *параметризованные*, *parametric*- объекты - это объекты, имеющие параметры в своем названии.  При определении параметрического объекта параметры в самом объекте задаются при помощи переменных.  Параметрический объект используется как терм-функтор (терм, состоящий из других термов, включая переменные) сам по себе, либо ему посылаются сообщения.

Основная идея, сложенная в параметрические объекты, та же - *инкапсуляция небора предикатов*, но в данном случае также *инкапсулируются* и *параметры объекта*, то есть и методы и параметры вместе.  Можно в первом приближении считать, что параметры входят неявно в каждый предикат в том или ином наборе.

Рассмотрим классический пример - представление даты ```date(_Year, _Month, _Day)```: ```_Year``` (год), ```_Month``` (месяц),  ```_Day``` (день).  Обращаем винмание, что теперь в идентификаторе объекта есть параметры: ```date/3```. Из основных функций реализуем установку/получение отдельных компонент даты (```year/1``` и другие), текущую дату ```today/0```, проверку на високосный год ```leap/0```.

В примере каждый из методов использует один или несколько параметров.  Чтобы получить доступ к каому-либо параметру объекта, Logtalk предоставляет встроенный локальный метод ```parameter/2```.  Первый параметр этого метода - номер параметра, начиная с 1, второй - переменная, унифицируемая с этим параметром.


```logtalk
% File: date_3.lgt

:- object(date(_Year, _Month, _Day)).

	:- info([
		version is 1:1:0,
		author is 'Paulo Moura',
		date is 2005-9-5,
		comment is 'Dates as parametric objects.',
		parnames is ['Year', 'Month', 'Day']
	]).

	:- public(year/1).
	:- mode(year(?integer), one).

	:- public(month/1).
	:- mode(month(?integer), one).

	:- public(day/1).
	:- mode(day(?integer), one).

	:- public(today/0).
	:- mode(today, one).

	:- public(leap_year/0).
	:- mode(leap_year, zero_or_one).

	year(Year) :-
		parameter(1, Year).

	month(Month) :-
		parameter(2, Month).

	day(Day) :-
		parameter(3, Day).

	today :-
		today(Year, Month, Day),
		parameter(1, Year),
		parameter(2, Month),
		parameter(3, Day).

    % Вспомогательный предикат, реализованный встроенными
    % в базовую библиотеку SWI-Prolog предикатами
    today(Year, Month, Day) :-
            get_time(TimeStamp),
            stamp_date_time(TimeStamp,
                date(Year, Month, Day, _,_,_,_,_,_),
                'UTC').

/*  % Альтернативные определения методов, использующие this/1 вместо parameter/2
    % (каждый из способов исользования обладаетс своими приемуществами и недостатками):

	year(Year) :-
		this(date(Year, _, _)).

	month(Month) :-
		this(date(_, Month, _)).

	day(Day) :-
		this(date(_, _, Day)).

	today :-
		today(Year, Month, Day),
		this(date(Year, Month, Day)).

*/

	leap_year :-
		parameter(1, Year),
		(	0 =:= mod(Year, 4), 0 =\= mod(Year, 100)
		;	0 =:= mod(Year, 400)
		), !.

:- end_object.
```

Другим способом, закомментированном в примере, является использование встроенного локального метода ```this/1```.  Private-метод ```this/1```, принадлежащий, по правде говоря, всем объектам, унифицирует свой единственный аргумент с термом, обозначающим объект.  В результате унификации можно сопоставить сразу все параметры.  Существуют еще способы получить параметры, но о них в следующих примерах.

Оба варианта одинаково эффективны, поскольку вызовы методов «this/1» и «parameter/2» обычно компилируются в виде унификации с заголовком.   Недостатком второго решения является то, что вынуждены проверять все вызовы «this/1», если изменим струткуру терма объекта. Обратите внимание, что мы не можем использовать этот метод с операторами отправки сообщений.  Итак, ```parameter/2``` позволяет получать параметры по одному, ```this/1``` все сразу.

Обратим внимание на поименование файла, в котором мы храним код нашего объекта. По соглашению название файла будет состоять из назавния объекта и его арности. Например, при определении объекта под названием ```date(_Year, _Month, _Day)```, предлагается его оформлять его код в текстовом файле ```date_3.lgt```.  Это соглашение позволяет избегать наложений имен файлов при определении объектов Logtalk, имеющих один и тот же функтор (название), но разные арности (количество аргументов).

Общая логика использования параметров - это передача одного значения группе предикатов, использующих эти переменные в своем определении.  Если состояние объекта устанавливается только при создании объекта и никогда не изменяется, то это решение намного лучше, чем использование базы данных объекта, изменяемой предикатами ```assert/1``` и ```retract/1```.  Параметрические объекты также могут быть использованы для создания ассоциаций набора предикатов с термами, которые имеют общий функтор и арность.  В приведенном выше примере такой ассоциацией являются методы ```today/0```, ```leap_year/0```, ```year/1```, использующие общий параметр ```Year```.

Потестируем наш объект.

<sample-output>

?- *date(Year, Month, Day)::today.*             % (1)
Year = 2025,
Month = 5,
Day = 9.

?- *Date=date(Year, Month, Day), Date::today.*  % (2)
Date = date(2025, 5, 9),
Year = 2025,
Month = 5,
Day = 9.

?- *Date=date(Year, Month, Day), Date::today,*  % (3)
*|     Date::leap_year.*
<b class="red" >false.</b>

?- *Date=date(2004, _, _), Date::leap_year.*    % (4)
Date = date(2004, _, _).

?- *Date=date(2004, _, _), Date::year(Year).*   % (5)
Date = date(2004, _, _),
Year = 2004.

</sample-output>

В примере запросы промумерованы, прокомментируем их немного.  Запрос (1) унифицирует ```Year```, ```Month```, ```Day``` с текущей датой.  Тут все просто, только необчно то, что мы *получаем значения параметров* параметрического объекта, посылая сообщение объекту, а не используем переданные конкретные значения в параметры при обработка сообщения.  Запрос (2) демонстрирует, как можно терм параметрического объекта ```date(Year, Month, Day)``` унифицировать с переменной ```Date```, и далее испольовать ее для посылки сообщений, получая тот же эффект как и в запросе (1).  Запрос (3) проверяет, является текущй год високосным, ответ - отрицательный.  Запрос (4) gпроверяет, является ли 2004 год високосным - ответ "да".  Запрос (5), самый простой, показывает, как получить значение одного из параметров.

Если одному объекту, не обязательно параметрическому, передается несколько сообщений, то их последовательность можно перечислить в круглых скобках.  Например, запросы (3) и (4)-й с (5)-м переписываются следующим образом:

<sample-output>

?- *Date=date(Year, Month, Day), Date::(today, leap_year).*
<b class="red">false.</b>

?- *Date=date(2004, Month, Day), Date::(leap_year, year(Year)).*
Date = date(2004, Month, Day),
Year = 2004.

</sample-output>

## Использование переременных-параметров

Третий вариант доступа к параметрам объекта — использование *переменных-параметров* (*parameter variables*).  Несмотря на то, что переменные-параметры вводят понятие глобальных переменных внутри объекта, их специальный синтаксис вида "```_```имя_параметра```_```" позволяет избежать конфликтов и делает их легко узнаваемыми внутри описаний реализаций методов. Например:

```logtalk
% File: person_2.lgt

:- object(person(_Name_, _Age_)).

	:- info([
		version is 1:0:0,
		author is 'Paulo Moura',
		date is 2007-6-19,
		comment is 'Простое представление данных о людях с использованием параметрических объектов.',
		parnames is ['Name', 'Age']
	]).

	:- public(grow_older/1).
	:- mode(grow_older(-object_identifier), one).
	:- info(grow_older/1, [
		comment is 'Увеличивает возраст человека, возвращая обновленный объект.',
		argnames is ['NewPerson']
	]).

	grow_older(NewPerson) :-
		::age(OldAge, NewAge, NewPerson),
		NewAge is OldAge + 1.

	:- protected(age/3).
	:- mode(age(?integer, ?integer, -object_identifier), zero_or_one).
	:- info(age/3, [
		comment is 'Создает новый объект - человек с обновленным возрастом.',
		argnames is ['OldAge', 'NewAge', 'NewPerson']
	]).

	% Здесь используются переменные-параметры.
	age(_Age_, NewAge, person(_Name_, NewAge)).

:- end_object.
```

Посмотрим, как теперь один объект порождает другой.

<sample-output>

?- *person('Donald Trump', 72)::grow_older(NewTrump).*
NewTrump = person('Donald Trump', 73).

</sample-output>

Объекту ```NewTrump``` можно снова послать сообщение и получить следующий объект и так далее.


## Наследование (расширение) параметрических объектов

Наследование через расширение объектов делается вполне очевидным способом - передачей параметров через унификацию.

```logtalk
% File: employee_3.lgt

:- object(employee(_Name_, _Age_, _Salary_),
	extends(person(_Name_, _Age_))).

	:- info([
		version is 1:0:0,
		author is 'Paulo Moura',
		date is 2007-6-19,
		comment is 'Простое представление данных сотрудников с использованием параметрических объектов.',
		parnames is ['Name', 'Age', 'Salary']
	]).

	:- public(give_raise/2).
	:- mode(give_raise(+integer, -object_identifier), one).
	:- info(give_raise/2, [
		comment is 'Дает повышение сотруднику, возвращая обновленного сотрудника.',
		argnames is ['Amount', 'NewEmployee']
	]).

	give_raise(Amount, NewEmployee) :-
		::salary(OldSalary, NewSalary, NewEmployee),
		NewSalary is OldSalary + Amount.

	:- protected(salary/3).
	:- mode(salary(?integer, ?integer, -object_identifier), zero_or_one).
	:- info(salary/3, [
		comment is 'Создает сотрудника с обновленной зарплатой.',
		argnames is ['OldSalary', 'NewSalary', 'NewEmployee']
	]).

	salary(_Salary_, NewSalary, employee(_Name_, _Age_, NewSalary)).

	age(_Age_, NewAge, employee(_Name_, NewAge, _Salary_)).

:- end_object.
```

Потестируем новый объект, выполнив старый запрос и еще один новый.

<sample-output>

?- *employee('Donald Trump', 72, 1_000_000)::grow_older(NewTrump).*
NewTrump = employee('Donald Trump', 73, 1000000).

?- *employee('Donald Trump', 72, 1_000_000)::give_raise(100_000, NewTrump).*
NewTrump = employee('Donald Trump', 72, 1100000).

</sample-output>

Метод ```age/3``` в объекте ```employee/3``` переопределен с целью адаптации к структуре ```employee/3```: он, например, возвращает новый объект не ```person/2```, а ```employee/3```.  Public-метод ```grow_older/1```, определенный в ```person/2``` и унаследованный в ```employee/3```, пользуется ```age/3```, посылая сообщение самому себе ```::age(...)```:

```logtalk
% контекст объекта person/3

	grow_older(NewPerson) :-
		::age(OldAge, NewAge, NewPerson),
		NewAge is OldAge + 1.
```

В качестве управжнения предлагается определить ```age/3``` в ```employee/3``` при помощи вызова к super-объекту ```^^age(...)``` (в ```person/2```).

<!---
A quiz to review the contents of this section:

<quiz id="900c0293-b14c-5736-b1a3-68d4fa01ac43"></quiz>
-->
