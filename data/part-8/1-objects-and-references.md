---
path: '/part-8/1-component-representation'
title: 'Представление компонент'
hidden: false
---

<text-box variant='learningObjectives' name="Цель освоения материала">

Результатом освоения материала данного раздела будет

- Понимание парадигмы компонентного проектирования и программирования
- Представления компонент средствами языка Logtalk

</text-box>

Разработка больших программных систем практически всегда является сложным и трудоемким процессом, где объектно-ориентированный подход к анализу, проектированию и реализации (программированию) достаточно хорошо себя зарекомендовал.  Проектирование программного обеспечения с использованием компонентного подхода становятся все более и более популярным методом проектирования.  Компонентный подход и unit-тестирование позволяет разрабатывать и поддерживать программные системы планомерно с обеспечением необходимого уровня надежности.  Существует много различных программных инфраструктур и инструментариев разработчика (framework), реализующих компонентное проектирование для разных языков программирования и их средах, некоторые даже не зависят от какой-либо конкретной среды разработки.  Примерами выступают COM, разработанный Microsoft, XPCOM - Mozilla, сроеда программирования DotNet.  Суть компонентного проектирования удобно изучать, неожиданно, в среде программирования языка Python, где в начаде 2000-х была разработана Компонентная архитектура Zope (Zope Component Architecture, ZCA).  ZCA реализует компонентный подход средствами языка Python, позволяет проектировать большие программные системы в этой среде.

**Компоненты** - это объекты, которые предназначены для планомерного повторного использования.  Основная идея компонентного проектирования стостоит в том, чтобы представлять сложные программные системы в виде модулей (объектов, в частности), соединенние друг с другом как кирпичики конструктора "Лего".  "Кирпичики" настроены на конкретный вариант реализации его функций, а их совокупность настроена таким образом, чтобы реализовывать функции программной системы.  Вся вовокупность настроек называется **конфигурацией** компонент программной системы.  Чтобы компоненты могли взаимодействовать друг с другом, их соответствующим образом "оформляют" при помощи *интерфейсов* и их реализацией, а также регистрируют в базе компонент, иногда, называемой *реестром* комопнент, *репозитарием* компонент, *регистр* (*registrar*), *каталог* и т.п.

**Интерфейс** - это объект или языковая конструкция, который описывает как следует взаимодействовать с конкретной компонентой.  В одном из вариантов интерпретации роли интерфейса в компонентных архитектурах предполагается, что **компонента** **оснащает** (обслуживает, **provides**) **интерфейс** или набор интерфейсов, то есть методы, перечисленные в интерфейсе.  Обычно компонентами выступают экземпляры классов, объекты-инкапсуляции (в том числе синглтоны), модули, отдельные функции, оформленные в системе стандартными средствами ассоциации интерфейса с модулем, функцией и т.д.

Компонента **реализуется** (is implemented) в виде класса (class) в языках объективно-ориентированного программирования, основанных на иерархии классов, или копии объекта-прототипа в языках типа JavaScript.  Отличие понятий *оснащение* (provision) от *реализации* (implementation) состоит в том, что *оснащение* осуществляется во время исполнения программной системы, например, вызванный метод исполняется кодом экземпляра некоторого класса.  *Реализация* - представление алгоритма реализации метода средствами языка программирования, в частности, классом.  Реализация относится только к процессу программирования.

Не важно, как реализована компонента, а вот что важно - это то, что она соответствует **требованиям**, определенным в интерфейсе (**interface contract**).  При помощи компонентных архитектур сложность системы распределяется между множеством кооперирующихся компонент.  Механизм кооперации реализуется двумя базовыми разновидностями компонент **адаптерами** (**adapters**) и **утилитами** (utilities).  Утилиты иногда называются *сервисами*.

**Адаптер** - это компонента, оснащающая один интерфейс, использующая другой.  Другими словами, адаптер преобразует один интерейс в другой, как устройства, позвояющие плоские вилки 220в из китая и америки "втыкать" в европейские.

**Утилита** - это компонента, реализующая некоторую часто используемую функцию, например, регистр компонент, соединение с сервером базы данных, фабрики компонент, раздел сайта и т.п.

Так вот, собирая с единую систему компоненты (экземпляры классов, функции, модули и др.), стыкуя их через интерфейсы, конфигурируя компоненты и эту систему, производится проектирование сложных систем.  Причем каждая компонента проектируется таким образом, чтобы ее можно было разрабатывать независимо.  В компонентных архитектурах язык программирования - это, как правило, инструмент реализации компонент, причем инкапсуляция, наследоание, полиморфизм и другие опрации - это только инструменты.  Как конкретно следует в конкретной архитектуре реализовывать компоненты излагается в методических материалах для конкретного языка программирования.

## Компонентное программирование на Logtalk

Для создание компонентной архитектуры необходимо разработать методику проектирования, в частности решить вопросы:

- Как задавать интерфейсы компонент?
- Какие программные объекты могут выступать в качестве компонент?
- Как создавать и порождать компоненты?
- Как регистрировать компоненты, ассоциируя их с интерфейсами?
- Как получать компоненты по идентификатору интерфейса?
- Как конфигурироавть компоненты?
- Как конфигурировать программную систему?

Кроме этих вопросов разрабатываются стандартные утилиты:

- Регистрация и доступ к компонентам.
- Регистрация, передача и генерация сообщений.

## Требования к системе

Рассмотрим классический пример - каталог файлов, где и каталог и файлы - это компоненты. Файлы можно добавлять в каталог, и только файлы.  Проверка добовляемого объекта, что он файл осуществляется при помощи данных о том, оснащает ли он соответствующий интерфейс.

## Интерфейсы

Начнем с интерфейса файла.  Файл обладает именем и размером.  Интерфейсы компонент, очевидно, задаются протоколами Logtalk.

```logtalk
:- protocol(file_p).
   :- info([
      comment is 'Интерфейс компонет-файлов',
      author is 'Evgeny Cherkashin',
      date is 2025-05-14
   ]).

   :- public(name/1).
   :- mode(name(-symbol), one).
   :- info(name/1, [
      comment is 'Имя файла',
      argnames is ['Name']
   ]).

   :- public(size/1).
   :- mode(size(-integer), one).
   :- info(size/1, [
      comment is 'Размер файла',
      argnames is ['Size']
   ]).

:- end_protocol.

```

Интерфейс каталога.  В каталог можно добавлять файл, удалять их него файлы, показывать список хранимых файлов.  Каталоги также можно добавлять в другие каталоги, поэтому протокол каталога имеет смысл унаследовать от протокола файлов.

```logtalk
:- protocol(catalog_p,
      extends(file_p)).

   :- info([
      comment is 'Интерфейс каталога, способного хранить файлы',
      author is 'Evgeny Cherkashin',
      date is 2025-05-14
   ]).

   :- public(add/1).
   :- mode(add(+object), one).
   :- info(add/1, [
      comment is 'Добавляет файл в каталог',
      argnames is ['File']
   ]).

   :- public(remove/1).
   :- mode(remove(?object), zero_or_more).
   :- info(remove/1, [
      comment is 'Удаляет файлы из каталога',
      argnames is ['File']
   ]).

   :- public(file/1).
   :- mode(file(?object), zero_or_more).
   :- info(file/1, [
      comment is 'Запрашивает файлы из каталога',
      argnames is ['File']
   ]).

:- end_protocol.

```

### Реализация файла и каталога

Действуя по классической схеме, то есть в предположении, что файлы и каталоги создаются динамически используем иерархию классов.

```logtalk

% сообщаем Logtalk, что не следует выдавать предепреждение
% об использовании в определениях неизвестных объектов
% class к настоящему времени неизвестен, но он нам нужен.
:- set_logtalk_flag(unknown_entities, silent).

% Корень иерархии классов
:- object(meta_class,
    instantiates(class)).

    % предикаты, видимые во всех объектах иерархии

:- end_object.
```

Объект ```meta_class/0``` - это *специализация* ```abstract_class/0```, здесь можно определить предикаты, видимые для всем классам.  Объект ```meta_class/0``` теперь это мета-класс по умолчанию для абстрактных классов.

```logtalk
:- object(abstract_class,
    instantiates(class),
    specializes(meta_class)).

    % предикаты, видимые во всех классах

    :- public(new/1).

    new(Object) :-
       self(Self),
       create_object(Object, [instantiates(Self)], [], []).

:- end_object.


% восстанавливаем механизм отслеживания неизвестных объектов
:- set_logtalk_flag(unknown_entities, warning).

```

Класс ```class/0``` - специализация  абстрактного класса, добавляет предикаты, видимые всем классам, от которых можно порождать экземпляры.  Он является корнем дерева порождения экземпрпляров, и мета-классом по умолчанию для этих классов.

```logtalk
:- object(class,
    instantiates(class),
    specializes(abstract_class)).

    % предикаты, видимые во всех экземплярах
    :- public(implements_protocol/1).
    implements_protocol(Proto):-
       self(Instance),
       current_object(Instance), % Не нужен
       implements_protocol(Instance, Proto), !.
    implements_protocol(Proto):-
       self(Instance),
       current_object(Instance), % Не нужен
       instantiates_class(Instance, Class),
       ci_implements_protocol(Class, Proto), !.
    implements_protocol(Proto):-
       self(Self),
       format(atom(Message),
          'is not an object or it does not implement ~q protocol', [Proto]),
       throw(exception(
          domain_error(object, Self),
          context(Self, Message))).

    ci_implements_protocol(Class, Proto) :-
       implements_protocol(Class, Proto), !.
    ci_implements_protocol(Class, Proto) :-
       specializes_class(Class, SuperClass),
       ci_implements_protocol(SuperClass, Proto).

:- end_object.
```

Согласно базовой идее объектно-ориентированного логического программирования Logtalk - быть как можно более статическим - представим файлы параметрическим объекном.

```logtalk
:- object(file(_Name_, _Size_),
   implements(file_p),
   specializes(class),
   instantiates(abstract_class)).

   name(_Name_).

   size(_Size_).

:- end_object.
```

Попробуем создать наш экземпляр ```file1/0``` параметрического класса ```file(name,100)``` и пошлем несколько сообщений.

<sample-output>

?- *create_object(file1, [instantiates(file(name,100))], [], []).*
true.

?- *file1::name(Name).*
Name = name.

?- *file1::size(Size).*
Size = 100.

</sample-output>

Все отлично работает.

### Реализация каталога

```logtalk
:- object(catalog(_Name_),
   implements(catalog_p),
   specializes(class),
   instantiates(abstract_class)).

   :- protected(file_/1).
   :- dynamic(file_/1).

   name(_Name_).

   :- use_module(library(apply), [foldl/4]).

   size(Size) :-
      findall(S,
         (::file(File),
          File::size(S)),
         L),
      foldl(plus, L, 0, Size).

   add(File) :-
      (::file(File) -> fail;
       File::implements_protocol(file_p),
       % \+ self(File),  % Не добавлять самого себя
       ::assertz(file_(File))).

   remove(File) :-
      (::file(File) -> ::retract(file_(File));
       fail).

   file(File) :-
      ::file_(File).

:- end_object.
```

## Тестирование компонент

Проведем серию тестов, посмотрим правильно ли функционирует наша система компонент. Сначала проведем функциональные тесты: создадим экземпляры файлов и каталогов, добавим файлы в каталоги, один каталог в другой.  В процессе будем также наблюдать, как меняется размер каталога (суммарный размер составляющих элементов).

<sample-output>

?- *catalog(main)::new(Cat), file('autoexec.bat', 400)::new(File), Cat::add(File).*
Cat = o1,
File = o2.

?- *catalog(main)::new(Cat), file('autoexec.bat', 400)::new(File), Cat::add(File).*
Cat = o3,
File = o4.

?- *o1::add(o4).*
true.

?- *o1::size(S).*
S = 800.

?- *o1::add(o3).*
true.

?- *o1::size(S).*
S = 1200.

?- *o1::file(File).*
File = o2 *;*
File = o4 *;*
File = o3.

</sample-output>

Несколько неудобно использовать синтетические названия объектов ```oX/0```.  Предикат ```create_object/4``` можно настроить, чтоб он определенным образом синтезировал названия для новых объектов.

Теперь проверим можно ли добавить объект "со стороны", объект, который не реализует протокол ```file_p```.

<sample-output>



</sample-output>
