---
path: '/part-2/1-state-save-change'
title: 'Хранение и изменение состояния объекта'
---

<text-box variant='learningObjectives' name="Цель изучения раздела">

После изучения данного раздела вы сможете

- Создавать объекты, которые будут менять свое состояние
- Задавать динамические предикаты/методы
- Изменять данные, ассоциироавнные с объектом

</text-box>

В первом разделе специально акцентировалось внимание на том, что родовое свойство языка Logtalk - это представлять теории, статические по своей природе, доказывать или опровергать в них некоторое утверждение или же получать логические следствия из этих теорий.  Мы привели несколько примеров объектов-теорий, реализующих данную парадигму программирования (инкапсуляция списков и система объектов, представляющих семейные отношения).  Однако, некоторые задачи, точнее большое количество задач, проще и удобнее решать за рамками ограничений статической парадигмы.  Примерами таких программ выступают решения задач сканирования входного потока данных и вычисления на их основе агрегированных значений.

## Сохранение состояния в объекте

Хранение состояния в обычных языках объектно-ориентированного программирования осуществляется с _атрибутах_ объекта, например, в языке Java это поля, которым можно присваивать значения:

```java
public class Person {
  private String name; // private = ограниченный
                       // доступ к атрибуту
  // Метод для получения значения (getter)
  public String getName() {
    return name;
  }

  // Метод для установки значения (setter)
  public void setName(String newName) {
    this.name = newName;
  }
}
```

В примере поле (атрибут) ```name``` представляет состояние объекта. Его значение можно получить методом ```getName``` (_getter_ method) и змнить ```setName``` (_setter_ method).  Процесс установки значения строго контролируется реализацией класса ```Person```: поде ```name``` является приватным, а getter и setter - public-методы.

Объекты языка Logtalk являются инкасуляциями методов, которые являются предикатами Prolog.  У качестве предикатов выступают факты и правила.  Факты могут быть динамическими, и список фактов в _рабочей памяти_ программы, называемой также _базой данных_ программы, меняется при помощи специальных предикатов ```asserta/1```, ```assertz/1```, ```retract/1```, ```retractall/1```.  Таким образом, состояние объекта определяется набором фактов, инкапсулированных в объекте, причем это набор предполагается изменять.

Рассмотрим пример-аналог Java-классу ```Person```, объект ```President```.  Здесь мы пытаемся оставаться в рамках только объектов-инкапсуляций и не используем _классы_ в их обычном понимании.

```logtalk
% File: president.lgt

:- object(president).
   :- public([
      name/1,
      current_name/1
   ]).

   :- private(name_/1).
   :- dynamic(name_/1).

   name(Name) :-
      retractall(name_(_)),
      assertz(name_(Name)).

   current_name(Name) :-
      name_(Name), !.

:- end_object.
```

Имя презилента храниться в приватном динамическом факте ```name_/1``` (```name``` с подчерком ```_```).  Имя выбрано таким образом, чтобы не накладываться на public-метод ```name/1```, используемый для "установки" имени презилента.  В реализации "присвоения" имени метод ```name/1``` сначала удалает все предыдущие значения, затем добавлвет новое.  Метод ```current_name``` возвращает одно и только доно значение имени президента.  Такое длинное название getter-а - дань традиции: большинство предикатов Logtalk, перечисляющие объекты в среде исполнения программы, называются ```current_<название вида объекта>/N```, где ```N``` - количество аргументов, ```N>0```.

Потестируем наш объект.

<sample-output>

?- **{president}.**
<b class="green">% [ /home/eugeneai/tmp/lgt/president.lgt loaded ]
% (0 warnings)</b>
true.

?- **president::current_name(Name).**
<b class="errLog">false.</b>

?- **president::name('Donald Trump').**
true.

?- **president::current_name(Name).**
Name = 'Donald Trump'.

</sample-output>

Первый запрос был неудачный, так как в базе данных объекта ```present/0``` не было каких-либо фактов.  Далее мы установили (добавили) имя президенту и последующий запрос, тот же, что и первый, уже удачно выполнился.

## Особенности управления динамическими предикатами

В Logtalk использование ```assertz/1```, ```asserta/1```, ```retract/1``` и ```retractall/1```, а также некоторыми другими встроенными предикатами связано с некоторыми особенностями.

Создадим еще одного президента, унаследовав первого.

```logtalk
% File: another_present.lgt

:- object(another_president,
   extends(president)).

:- end_object.
```

Проведем серию тестов в продолжении предыдущей сессии командной строки.

<sample-output>

?- **{another_president}.**
% [ /home/eugeneai/tmp/lgt/another_president.lgt loaded ]
% (0 warnings)
true.

?- **president::current_name(Name).**
Name = 'Donald Trump'.

?- **another_president::current_name(Name).**
Name = 'Donald Trump'.

?- **another_president::name('Barak Abama').**
true.

?- **president::current_name(Name).**
Name = 'Barak Abama'.

</sample-output>

Как видно, имена обоих президентов совпадают - оба объекта обладают общей базой данных.  На самом деле, база данных принадлежит объекту ```president/0``` и манипуляции над ней осуществляется приватными вариантами предикатов ```assertz/1```, **меняющими локальный контекст**, то есть объект в котором эти **приватные** предикаты непосредственно выполняются и находятся.


<!-- Данный контекст обозначается в Logtalk как _this_.

Нам бы хотелось, чтобы ```assertz/1``` и ему подобные предикаты управляли базой данных объекта ```another_president/0```.  Это достигается другими вызовами: ```::assert(...)``` и ```::retractall(...)```, являющимися по умолчанию protected-методами.

```logtalk
% File: presidents.lgt

:- object(president).
   :- public([
      name/1,
      current_name/1
   ]).

   :- protected(name_/1).
   :- dynamic(name_/1).

   name(Name) :-
      ::retractall(name_(_)),
      ::assertz(name_(Name)).

   current_name(Name) :-
      name_(Name), !.

:- end_object.

:- object(another_president,
   extends(president)).

   :- protected(name_/1).
   :- dynamic(name_/1).


:- end_object.
```

-->

Самый простой способ распространить возможность установки имени у второго президента - это использование _категорий_ (_categories_).  Эти конструкции мы рассмотрим в одном из следующих разделов.

Пока расмотрим классический пример использования базы данных для "кэширования" ранее выисленных значений функции.  Используем функцию факториал, а Фибоначчи оставим для самостоятельной реализации.  Также введем в использования дополнительные конструкции документирования методов и объектов.

Здесь добавлены две подобные декларации для описания предназначения объекта и публичного метода.   Первая реализована на основе ```info/1``` и задает версию объекта (version), автора (author), дату последнего изменения объекта (date) и назначение (comment).  Вторая, ```info/2``` в качестве первого аргумента получает идентификатор метода, а в списке второго аргумента указывается перечень названий аргументов.

```logalk
% File: cached_fact.lgt

:- object(cached_fact).

   :- info([
      version is 1:0:0,
      author is 'Evgeny Cherkashin',
      date is 2025-01-20,
      comment is 'Кэшированный вариант функции факториала'
   ]).

   :- public(fact/2).
   :- mode(fact(+integer, ?integer), zero_or_one).
   :- info(fact/2, [
      comment is 'Функция вычисления факториала',
      argnames is ['Number', 'Value']
   ]).

   :- private(fact_/2).
   :- dynamic(fact_/2).

   fact(0, 1):-!.
   fact(1, 1):-!.
   fact(N, F):-
      fact_(N, F),!.
   fact(N, F):-
      N1 is N-1,
      fact(N1, F1),
      F is F1*N,
      assertz(fact_(N, F)).

:- end_object.
```

Выполним несколько тестов над нашим объектом.

<sample-output>

?- **{cached_fact}.**
% . . . . . . .

?- **cached_fact::fact(20,X).**
X = 2432902008176640000.

?- **cached_fact::fact(20,X).**
X = 2432902008176640000.

?- **forall(cached_fact<<fact_(N, F), format('fact(~w) = ~w\n', [N,F])).**
fact(2) = 2
fact(3) = 6
fact(4) = 24
fact(5) = 120
fact(6) = 720
fact(7) = 5040
fact(8) = 40320
fact(9) = 362880
fact(10) = 3628800
fact(11) = 39916800
fact(12) = 479001600
fact(13) = 6227020800
fact(14) = 87178291200
fact(15) = 1307674368000
fact(16) = 20922789888000
fact(17) = 355687428096000
fact(18) = 6402373705728000
fact(19) = 121645100408832000
fact(20) = 2432902008176640000
true.

</sample-output>

Как видно, в процессе вычислений сгенерирована база данных для значений факториалов в диапазоне [2,20].


<!--

A quiz to review the contents of this section:

<quiz id="eb4b41d3-b83b-5815-a1d5-ae9b377aa274"></quiz>


-->
