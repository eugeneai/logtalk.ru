% Добро пожаловать в первый набор упражнений по языку Logtalk!
% Редактируйте этот файл в соответствии с инструкциями.
% Для проверки выполнения заданий запускайте:
% swilgt -l Set1TestsLoader.lgt -g halt
%
% Также можно после проверки задания перейти в командную
% строку Logtalk (top-level) и позадавать запросы.
%
% swilgt -l Set1TestsLoader.lgt
%
% Данный набор тестов содержит задачи по темам
%
%   - определение объектов
%   - задание предикатов-методов
%   - определение области видимости
%   - наследование объектов

% ВАЖНО: Выполняйте упражнения по порядку, так как они связаны между собой!

% -----------------------------------------------------
% Упражнение 1: Задайте объект с названием first,
% содержащий два факта, что butsy и flash - кошка (cat) и
% собака, соответственно (dog).
% используйте инструкцию
%
%   :- public([cat/1,dog/1]).
%
% чтобы система тестирования могла получить доступ к
% к вашим животным.

:- object(first).
    % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
    % Добавьте факты: butsy - кошка, flash - собака
:- end_object.


% -----------------------------------------------------
% Упражнение 2: Создайте объект second, унаследовав объект
% first. В новом объекте создайте правило animal/1 (животное),
% определяющее, что все кошки и собаки - это животные.
% используйте инструкцию public/1, чтобы указать Logtalk,
% что метод animal/1 - публичный.
% Напоминание: dog/1 и cat/1 - матоды, вызов своего метода
% реализуется оператором ::/1.
% Используйте ^^/1 для вызова унаследованных методов.

:- object(second,
     extends(first)).
     % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
     % animal(X) истинно, если X - собака ИЛИ X - кошка
:- end_object.


% -----------------------------------------------------
% Упражнение 3: Реализуйте объект third, скопировав объект
% first. Укажите, что dog/1 и cat/1 - защищенные методы.
% ПРИМЕЧАНИЕ: Защищенные методы видны наследникам, но не снаружи.

:- object(third).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % Скопируйте факты из first, но объявите их protected
:- end_object.

% -----------------------------------------------------
% Упражнение 4: Реализуйте объект fourth, скопировав объект
% second. Объект должен наследовать third.
% ПРИМЕЧАНИЕ: Проверьте, сможет ли animal/1 получить доступ
% к защищенным методам через ::/1.

:- object(fourth,
     extends(third)).
     % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
     % Правило animal/1 должно использовать ::dog и ::cat
:- end_object.

% -----------------------------------------------------
% Упражнение 5: Реализуйте объект fifth, унаследовав
% объект fourth. Добавьте:
% - факты, что star и iron - это лошади (horse) - protected
% - правило, что лошади тоже животные (используйте ^^ для вызова родительского animal)
% - правило, что кошки и собаки - домашние животные (pet) - public
% ПРИМЕЧАНИЕ: ^^animal(X) вызывает animal/1 из родительского объекта.

:- object(fifth,
   extends(fourth)).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % 1. Факты horse/1 (protected)
   % 2. Расширенное правило animal/1 (включает лошадей)
   % 3. Правило pet/1 (только кошки и собаки)
:- end_object.

% -----------------------------------------------------
% Упражнение 6: Реализуйте объект sixth, унаследовав
% объект fifth. Добавьте публичный предикат owner/2:
% - Kate (kate) владеет всеми домашними животными
% - Bob (bob) владеет только лошадью star
% ПРИМЕЧАНИЕ: Используйте ::pet и ::horse для проверки.

:- object(sixth,
    extends(fifth)).
    % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
    % owner(kate, X) :- ... (все домашние животные)
    % owner(bob, X) :- ... (только лошадь star)
:- end_object.

% -----------------------------------------------------
% Упражнение 7: Реализуйте объект table_animal_printer.
% Теперь нам надо вывести на стандартный вывод (экран)
% таблицу владельцев животных в фромате:
% <имя владельца>:<имя животного>.
% Вышеуказанный вывод должен реализовываться методом
% print/1, единственный параметр которого - это объект
% типа sixth.
% Примечание 1: Для получения всех ответов предиката
% Можно использовать кострукции с fail или forall/2.
% Примечание 2: Печать на экран - смотритее описание format/2.
% Примечание 3: Вызов метода объекта реализуется
% оператором ::/2. Пример - red_hat::walk_to_forest(F).
% Проверить работу table_animal_printer можно в командной
% строке logtalk:
%
% ?- table_animal_printer::print(sixth).
% kate:flash
% kate:butsy
% bob:star
% true.
%
% Для этого надо запустить тестирование без флага -q halt:
%
% swilgt -l Set1TestsLoader.lgt
%
% Итак, метод print/1 должен выводить таблицу владельцев животных
% в формате: <имя владельца>:<имя животного>
% ПРИМЕЧАНИЕ: Используйте forall(Объект::owner(O,A), format(...))

:- object(table_animal_printer).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
:- end_object.


% -----------------------------------------------------
% Упражнение 8: Реализуйте объекты dog_object, cat_object.
% Объекты должны задавать два предиката:
%   - say/1, защищенный (protected)
%   - say_something/0, публичный.
% аргументом say/1 у них должны быть строки "meow" и
% "wow", соответственно.
% say_something/0 должен выводить аргимент say/1 на экран,
% печатать сразу после слов "!!!" и переводить строку (!).
% Примечание: при реализации можно создавать дополнительные
% объекты (или категории), использовать наследование
% (и/или композицию), можно использовать протоколы.
%
% Пример использования:
% ?- dog_object::say_something.
% wow!!!
% true
% Таким образом, объекты должны содержать:
% - защищенный предикат say/1 ("meow"/"wow")
% - публичный say_something/0 (выводит say/1 с "!!!")
% ПРИМЕЧАНИЕ: Используйте протокол и наследование для избежания дублирования.

% Протокол для единообразного интерфейса
:- protocol(say_p).
   % Объявите say/1 как protected
:- end_protocol.

% Базовый объект с общей логикой
:- object(animal_object).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % say_something должен использовать ::say(S)
:- end_object.

% Конкретные реализации
:- object(dog_object).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % say("wow")
:- end_object.

:- object(cat_object).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % say("meow")
:- end_object.

% -----------------------------------------------------
% Упражнение 9: Реализуйте объект taylor инкапсулирующий
% приватный fact/2, истинный, если второй аргумент является
% факториялом первого;
% приватный sqr/2, истинный, если второй аргумент - квадрат
% первого
% публичный exp/3 - разложение функции exp(x) (e^x)
% в ряд Тейлора вокруг точки
%   - x (первый аргумент);
%   - второй аргумент, целое число - количество членов
%     разложения, начиная с 1;
%   - третий аргумент - результат разложения.
% exp(x) = 1 + x/1! + x^2/2! + x^3/3! ...
%          0   1      2        3      ... (количество членов)
% Примечание 1: все методы должны быть детерминированными.
% Примечание 2: exp(_, 0, 1.0) положим истинным.
% Примечание 3: вызов приватных предикатов при помощи ::/1
% порождает замечание (Warning), поэтому не используйте ::/1
% в реализации exp/3.
% Тесты предполагают, что все определено в одном объекте
% taylor (без какого-либо наследования).
% Тестирование предикатов в командной строке можно
% делать при помощи переключения контекста <</2, т.е.
% инструмента запуска изнутри объекта private-предикатов:
%
% ?- taylor<<fact(10,X).
% X = 3628800.
%
% Таким образом, реализуйте объект taylor с:
% - приватными fact/2 (факториал) и sqr/2 (квадрат)
% - публичным exp/3 (разложение exp(x) в ряд Тейлора)
% Формула: exp(x) = 1 + x/1! + x^2/2! + x^3/3! + ...
% ПРИМЕЧАНИЕ: exp(_, 0, 1.0) - базовый случай.

:- object(taylor).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % private([fact/2, sqr/2])
   % public(exp/3)
   % fact(0, 1) и fact(N, F) рекурсивно
   % exp(X, N, R) рекурсивно накапливает сумму
:- end_object.

% -----------------------------------------------------
% Упражнение 10: Реализуйте объект evaluator, который
% содержит предикат eval/2, получающий в качестве
% первого параметра выражение вида
%    and(or(t,f),not(and(t,t)))
% второй параметр - вычисленное логическое значение
%    t или f.
% Только eval/2 должен быть публичным и детерминированным.

:- object(evaluator).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % public(eval/2)
   % Рекурсивно обрабатывайте сложные выражения
:- end_object.

% -----------------------------------------------------
% Упражнение 11: Реализуйте объект door_lock такой, чтобы
% при наследовании от него можно было добавлять новые пароли.
% Публичный метод check/1, который истинный, если
% в списке паролей password/1 имеется пароль, совпадающий с
% аргументом.
% Пароли не должны быть доступны снаружи.
% Примечание: тип данных строк паролей - символы, например
% 'password', 'award_ed', '42', т.е. символы в одинарных
% кавычках.
% Тесть будет выполнен, если все пароли в door_lock будут
% доступны в my_door_lock. В my_door_lock должны быть пароли,
% не входящие в door_lock. Все пароли проверяются
% my_door_lock::check/1.
% Резюме упражнения: реализуйте систему паролей с наследованием.
% door_lock: базовые пароли, защищенный password/1, публичный check/1
% my_door_lock: добавляет новые пароли, сохраняя унаследованные
% ПРИМЕЧАНИЕ: Используйте ^^password(X) для доступа к родительским паролям.

:- object(door_lock).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % protected(password/1) с паролями
   % public(check/1) проверяет пароли
:- end_object.

:- object(my_door_lock,
   extends(door_lock)).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ
   % Добавьте новые пароли и вызовите родительские
:- end_object.

% -----------------------------------------------------
% Упражнение 12: Создайте объект animal_factory с методами:
% - create_cat/1 (создает объект кошки)
% - create_dog/1 (создает объект собаки)
% - list_animals/0 (выводит всех созданных животных)
% ПРИМЕЧАНИЕ: Используйте динамические факты для хранения животных.

:- object(animal_factory).
   % ВАША РЕАЛИЗАЦИЯ ЗДЕСЬ (ОПЦИОНАЛЬНО)
   % Динамические факты для хранения животных
   % Методы для создания и вывода
:- end_object.
