% Этот набор задач, второй по списку продвинутого уровня,
% преследует целью реализовать простую систему автоматического
% доказательства теорем (АДТ) в пропозициональном исчислении.
% Источник: И.Братко
% Язык программирования Prolog для искусственного интеллекта.
% http://lib.ysu.am/open_books/125049.pdf стр. 530 вам в помощь.
% В объекте реализована машина вывода на типовых конфигурациях,
% есть предикаты для обнаружения элемента в дизъюнкте,
% несколько правил реализованы как примеры и т.п.
% Надо реализовать оставшиеся правила, так, чтобы сработал тест.%
% Запуск тестирования:
%
% swilgt -l Set12TestsLoader.lgt -g halt
%
% Также можно запускать при должном уровне завершения практической
% работы:
%
% swilgt -l Set12TestsLoader.lgt
% ?- ip_zero_test::run.
%

% -----------------------------------------------------
% Упражнение 1: На первом этапе необходимо определить
% набор операторов (https://www.swi-prolog.org/pldoc/man?predicate=op/3):
%   - префиксный
%     '~' с приоритетом 100, левоассоциативный (left associative fy)
%   - инфиксные:
%     '&' с приоритетом 110, правоассоциативный (right associative)
%     'v' с приоритетом 120, правоассоциативный (right associative)
%     '=>'              130, правоассоциативный (right associative)
%     '<=>'             140, неассоциативный (no-associative, xfx).

:- op(100, fy, ~ ).
:- op(110, xfy, & ).
:- op(120, xfy, v ).
:- op(130, xfy, => ).
:- op(140, xfx, <=> ).


:- object(ip_zero).

% -----------------------------------------------------
% Упражнение 2: На втором этапе необходимо реализовать
% несколько вспомогательных предикатов. Их спецификации
% заданы надо дополнить декларации, реализовать.

   :- protected(clause/1). % Дизъюнкт, должен быть динамическим
   :- dynamic(clause/1).   %%

   :- protected(done/3).  % Фиксирует фак выполнения резолюции
   :- mode(done(?expression, ?expression, ?expression), zero_or_more).
   :- info(done/3, [
      comment is 'Информация об использованных резольвентах',
      argnames is ['Clause', 'Clause', 'Literal']
   ]).

   :- dynamic(done/3).    % должен быть динамическим.

   :- public(clear_db/0).
   :- info(clear_db/0, [
      comment is 'Удаляет содержимое БД объекта. Нужен для теста.'
   ]).

   % Реализуйте clear_db таким образом, чтобы он вычищал все
   % факты clause/1, done/3.
   clear_db:-
      retractall(clause(_)),
      retractall(done(_,_,_)).

% -----------------------------------------------------
% Упражнение 3: На данном этапе необходимо определить
% процедуру редукции формул языка, близкого к языку
% представления формул исчисления предикатов.

   :- protected(tr/2).  % Шаг редукции.
% Задача tr/2 - преобразовать формулу к каноническому виду -
% конъюнкции дизъюнкций, где дизъюнкция состоит из только
% литералов, т.е. атомов вид p и ~p. Преобразование должно быть
% реализовано детерминировано (с использованием отсечения).

% Правила следующие:
% 1. Избавление от двойного отрицания.
% 2. Эквивалентные преобразования:
%    импликация в дизъюнкцию
%    эквиваленцию в конъюнкция импликаций
% 3. ДВА правила Де Моргана - цель "утопить отрицание".
% 4. ДВА правила дистрибутивной конъюнкции (правая и левая).
% 5. ДВА правила редукции правой и левой подформулы в дизъюнкции.
% 6. Правило редукции подформулы отрицания.
% Итого должно быть 10 правил редукции.

   tr(~(~X), X) :-! .
   tr(X=>Y, ~X v Y) :- !.
   tr(X<=>Y, (X=>Y) & (Y=>X)) :- !.
   tr(~(X v Y), ~X & ~Y) :- !.
   tr(~(X & Y), ~X v ~Y) :- !.
   tr(X & Y v Z, (X v Z) & (Y v Z)) :-!.
   tr(X v Y & Z, (X v Y) & (X v Z)) :-!.
   tr(X v Y, X1 v Y) :- tr(X, X1), !.
   tr(X v Y, X v Y1) :- tr(Y, Y1), !.
   tr(~X, ~X1) :- tr(X, X1).

% -----------------------------------------------------
% Упражнение 4: Теперь самое интересное - необходимо
% реализовать преобразование формул пропозициональной
% логики предикатов в дизъюнкты.

   :- public(translate/1).
   :- mode(translate(+expression), one).
   :- info(translate/1, [
      comment is 'Выполняет редукцию формул (дизъюнктов) в канонический вид',
      argnames is ['Formula']
   ]).

% Первый предикат решает три задачи:

% 1. Конъюнкция формул A & B преобразуется параллельно для A и B.
   translate(F & G) :- !,
      translate(F),
      translate(G).
% 2. Другие формулы - делаем с ними следующее:
% Пробуем выполнить шаг редукции tr/2, если удалось, то выполняем
% преобразование (translate) для результата.
   translate(Expr) :-
      tr(Expr, Red), !, % Шаг редукции успешен
      translate(Red).

% Если не удалось выполнить преобразование tr/2, то аргумент
% добавляем в спосок дизъюнктов clause/1.
   translate(Clause) :- % Дальнейшая трансформация невозможна.
      assertz(clause(Clause)).

% -----------------------------------------------------
% Упражнение 5: Следующий этап проектирования прувера
% собственно реализация системы автоматичекского доказательства
% теорем (логический вывод). Реализоывываться он будет
% на основе программирования в типовых конфигурациях
% (pattern-directed programming).
%   Сначала запрограммируем машину - цикл запуска правил,
% который останавливается двумя командами, qed (что и
% трабовалось доказать) и halt (остановка в случае
% невозможности доказать формулу).
% Используйте ::rule(...) вызов, чтоб сработало тестирование.

   :- public(proof/0).
   proof :-
     ::rule(Name, Action), !,
     format('Используем правило \'~w\'.\n', [Name]),
     (Action == halt ->
        format('Нет противоречия, исходная формула не является теоремой'), true;
      Action == qed ->
        format('Найдено противоречие!\n'), true ;
      proof).

% -----------------------------------------------------
% Упражнение 6: Надо сформулировать процедуру удаления
% литерала из дизъюнкта.

   :- protected(remove/3).
   :- mode(remove(+expression, +expression, +expression), zero_or_one).
   :- info(remove/3, [
      comment is 'Удалить из дизьюнкта литеру/подформулу',
      argnames is ['Litral', 'Clause', 'Clause']
   ]).

   remove(X, X v Y, Y).
   remove(X, Y v X, Y).
   remove(X, Y v Z, Y v Z1) :-
      remove(X, Z, Z1).
   remove(X, Y v Z, Y1 v Z) :-
      remove(X, Y, Y1).

% -----------------------------------------------------
% Упражнение 7: Проектирование правил, выполняющих
% изменение формул и резолюцию дизъюнктов.


   :- protected(rule/2).
   :- mode(rule(-atom, -atom), one).
   :- info(rule/2, [
      comment is 'Правила, реализующие метод резолюции.',
      argnames is ['Rule name', 'Action']
   ]).


% Правило 'Распознавание противоречия' - среди набора дизъюнктов
% есть формулы P и ~P.

   rule('Find a contradiction'(A, ~A), qed) :-
      clause(A), clause(~A),!.

% Правило 'Удаление истинного дизъюмкта' - дизъюнкт, содержащий
% P и ~P.
   rule('Remove trivially true clause', tuth_remove) :-
      clause(A), remove(P, A, _), remove(~P, A, _), % пример правила.
      !,
      retract(clause(A)).

% Правило удаления дублей в дизъюнкте.
   rule('Remove double'(C, P, C1), remove_double) :-
      clause(C), remove(P, C, C1),
        ( remove(P, C1, _) -> true ; C1==P ), !,
      retract(clause(C)), assertz(clause(C1)).

% Правило удаления одинаковых дизъюнктов.
   % rule('Remove copy of a clause', remove_clause_copy) :-
   %    tbd('Удалить абсолютную копию дизъюнкта').

% Следующие правила реализуют метод резолюции. Важно - каждая резолюция должна
% выполняться один раз, чтоб не порождать дубли. Для этого будем использовать
% метод done/3, который будет задавать факт выполнения резолюции двух дизъюнктов
% с использованием конкретного литерала.

% Правило резолюции дизъюнкта-литерала и другого дизъюнкта. Надо проверить наличие
% противоположной литеры в дизъюнкте, удалить литеру в дизъюнкте и добавить результат
% (дизъюнкт к списку дизъюнктов).
   rule('Reduce trivial positive literal'(P, C, P, true, C1), reduce_p_literal) :-
      clause(P), clause(C), remove(~P, C, C1), \+ done(P, C, P), !,
      assertz(clause(C1)), assertz(done(P, C, P)).

% Правило резолюции дизъюнкта-литерала (отрицательного) и другого дизъюнкта.
% Надо проверить наличие противоположной литеры в дизъюнкте, удалить литеру
% в дизъюнкте и добавить результат (дизъюнкт к списку дизъюнктов).
   rule('Reduce trivial negative literal'(P, C, ~P, true, C1), reduce_not_p_literal) :-
      clause(~P), clause(C), remove(P, C, C1), \+ done(P, C, ~P), !,
      assertz(clause(C1)), assertz(done(P, C, ~P)).

% Правило резолюции, общий случай, двух дизъюнктов. В одном надо найти положительную,
% а в другом отрицательную литеры. Удалить их из своих дизъюнктов, из остатков
% сформировать новый дизъюнкт.
   rule('Reduction'(C1, C2, P, C1R v C2R), reduction) :-
      clause(C1), clause(C2),
      remove(P, C1, C1R),
      remove(~P, C2, C2R),
      \+ done(C1, C2, P), !,
      assertz(clause(C1R v C2R)), assertz(done(C1, C2, P)).

% Последнее правило, имеющее наименьший приоритет, останавливает процесс
% поиска вывода.

   rule('No contradiction', halt). % Невозможно продвинуться дальше - тупик, нет противоречия.


% Public-метод для тестирования систем АДТ.
   :- public(proof/2).
   :- info(proof/2, [
      comment is 'Строит доказательство. Используется в тесте',
      argnames is ['ResultTerm','Print?']
   ]).

   :- use_module(library(lists), [member/2]).

   proof(Result, Aloud) :-
     rule(Name, R), !,
     ( Aloud == true ->
        format('Правило:~w\n',[Name]) ; true),
     ( member(R, [qed, halt]) -> Result = R;
      proof(Result, Aloud)).

   :- public(print/0).
   print :-
     forall(clause(C),
       format('clause(~p).\n', [C])),
     forall(done(C1, C2, R),
       format('done(~p, ~p, ~p).\n', [C1, C2, R])).


:- end_object.


% объект-тест, раскомментировать после определения операторов,
% в упражнении 2.
%
% ?- ip_zero_test::run.  % командная строка Logtalk.
%

:- object(ip_zero_test,
   extends(studyunit)).

   test_name('Тест системы доказательства теорем в пропозициональном исчислении методом резолюции').

   debug_level(0).

   :- public(test_formula/1).

   test(prove_theorems,
      all(::mem(Formula, [
         c=>c,
         (a=>b) & (b=>c) => (a=>c),
         (p=>(q=>r))=>((p=>q)=>(p=>r)),
         ~(((~p v q v c) & (p v q v c) & ~(q v c)))
      ])),
      [
        each_explain(format('!ERROR:\n!Формула ~q является теоремой, а ваша машина не может это доказать!\n',
        [Formula])),
        each_test_name(theorem(Formula))
      ],
      (
        ip_zero_test::test_formula(
        Formula
       ))
   ).

   test(fail_to_prove_neg_c_to_c, fail,
      [explain(format('!ERROR:\n!Формула ~q точно не теорема, а ваша машина ее доказывает!\n',
       [~(c=>c)]))],
      ip_zero_test::test_formula(
        ~(c=>c)
      )
   ).

   test_formula(F) :-
     ::debug_level(DL),
     (DL>0 -> Aloud = true; Aloud = false),
     ip_zero::clear_db,
     ( Aloud == true -> format('Формула: ~q.\n', [F]); true),
     ip_zero::translate(~F),
     ( Aloud == true -> ip_zero::print; true),
     ::debug(1,"Доказательство:\n"-[]),
     ip_zero::proof(qed, Aloud),
     ::debug(1,"Конец вывода.\n"-[]),
     ( Aloud == true -> ip_zero::print; true),
     ::debug(1,"Конец теста.\n"-[]).


:- end_object.
